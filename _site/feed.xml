<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-03T18:16:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">kelpin’s blog</title><subtitle>kelpin의 블로그입니다. 학습했던 것을 정리해 블로그에 올리고 있습니다.</subtitle><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><entry><title type="html">Kubernetes 입문자를 위한 기초 내용 정리</title><link href="http://localhost:4000/kubernetes/kubernetes_basic/" rel="alternate" type="text/html" title="Kubernetes 입문자를 위한 기초 내용 정리" /><published>2019-12-26T00:00:00+09:00</published><updated>2019-12-26T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/kubernetes_basic</id><content type="html" xml:base="http://localhost:4000/kubernetes/kubernetes_basic/">&lt;h1 id=&quot;문서목적&quot;&gt;문서목적&lt;/h1&gt;

&lt;p&gt;이 문서는 Kuberetes에 대한 기초 내용을 개인적으로 내용을 정리하기 위하여 작성되었다.&lt;br /&gt;
자세한 내용이나 특정 항목에 대한 서비스의 구체적인 정보는 공식사이트 자료를 참고하도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;docker-기초-개념&quot;&gt;Docker 기초 개념&lt;/h2&gt;

&lt;h3 id=&quot;가상화의-정의&quot;&gt;가상화의 정의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 또는 상이한 여러 개의 운영체제를 완전히 독립된 방식으로 동시에 실행하는 것 (ex. 하나의 머신 위에 Linux와 Window 운영 체제를 동시에 실행)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;가상화의-장점&quot;&gt;가상화의 장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;하드웨어의 소프트웨어화 ⇒ 유연성, 자동화, 민첩성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;높은 하드웨어 활용도&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여러 개의 운영체제, 소프트웨어 운영 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;High Scalability&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;High Availability - Live Migration&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하드웨어 관리 부담 감소&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Migration 용이&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hypervisor&quot;&gt;Hypervisor&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;하드웨어와 가상화된 OS 사이에서 둘 사이의 인터페이스 역할을 하면서 하드웨어 자원을 가상화 OS에 공유해주고 관리하는 역할을 하는 소프트웨어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker에-대한-장점과-특징&quot;&gt;Docker에 대한 장점과 특징&lt;/h3&gt;

&lt;p&gt;도커와 VM의 아키텍쳐&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kube.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;docker란&quot;&gt;Docker란?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt; 컨테이너가 돌아갈 수 있는 환경을 제공&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt; 사실 상의 컨테이너 표준&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker의-장점-및-vm과-docker의-차이점&quot;&gt;Docker의 장점 및 VM과 Docker의 차이점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Light and Scalable&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Portable&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A container runs &lt;em&gt;natively&lt;/em&gt; on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.&lt;/p&gt;

&lt;p&gt;By contrast, a virtual machine (VM) runs a full-blown “guest” operating system with &lt;em&gt;virtual&lt;/em&gt; access to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.&lt;/p&gt;

&lt;h3 id=&quot;docker-컨데이터-개발-방법&quot;&gt;Docker 컨데이터 개발 방법&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kube2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 . 도커 워크플로우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dockerfile이란 빌드 파일을 통해서 이미지 생성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image를 Docker run 명령어로 Container 실행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker hub가 있어 공식 이미지 또는 커스텀 이미지를 올리고 내려 받을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Container는 Stateless이므로 영구 저장이 필요한 파일은 별도 스토리지에 저장해야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;kubernetes-기초-개념&quot;&gt;Kubernetes 기초 개념&lt;/h2&gt;

&lt;h3 id=&quot;kubernetes가-필요한-이유&quot;&gt;Kubernetes가 필요한 이유&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;수 많은 Docker들을 관리하기 위해&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최근 2017~2018년도 트렌드 분석 시 컨테이너 관리 표준 처럼 되어 가고 있는 것을 알 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes이하-k8s-pod&quot;&gt;Kubernetes(이하 K8S) Pod&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;K8S의 기본적인 관리 단위 -&amp;gt; 관리의 편의성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나 이상의 컨테이너를 가질 수 있음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공유 유틸리티 역할을 하는 컨테이너를 Pod에 같이 패키징 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;같은 Pod안의 컨테이너들은 IP 주소와 로컬 디스크를 공유 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 . Pods 구조 예시&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kube3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;k8s-아키텍처&quot;&gt;K8S 아키텍처&lt;/h2&gt;

&lt;h3 id=&quot;k8s-architecture-component&quot;&gt;K8S architecture, component&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kube4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;K8S는 Master component와 Node component로 구성되어 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Master component는 K8S Cluster의 컨트롤 영역을 제공한다. (ex. 배포, 스케줄링 등)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 Component의 자세한 설명은 공식 사이트 참조를 하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Components&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;kube-apiserver: K8S API 서버, All communication about cluster state flows through the API Server.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;etcd: AKA The API Server’s datastore, 영구적 저장&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kubelet: Communicates with API Server to know what pods it should run, Broadcasts status of pods, nodes&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;controller-manager: AKA managing controllers powering Kubernetes abstractions&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kube-scheduler: A control loop that is crucial to cluster operation by ensuring that nodes run pods&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;node: container runtime interface, default is docker. &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kube-proxy: manage network communication between node, pods. expose container traffic like load balancer&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;k8s-service&quot;&gt;K8S service&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Service- L4 Load balancer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kube5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;K8S ingress&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress-  L7 Load balancer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;URI 기반으로 서비스 별 라우팅&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Google Cloud의 Load balancer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kube6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;k8s-deployments-replicaset&quot;&gt;K8S Deployments&amp;amp; ReplicaSet&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Deployment가 복수개의 ReplicaSet을 통해 Rolling Update 방식으로 처리한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Kubernetes" /><summary type="html">이 문서는 Kuberetes에 대한 기초 내용을 개인적으로 내용을 정리하기 위하여 작성되었다.</summary></entry><entry><title type="html">AWS CLI 기초 학습 공유</title><link href="http://localhost:4000/aws_cli/aws_cli_basic/" rel="alternate" type="text/html" title="AWS CLI 기초 학습 공유" /><published>2019-12-26T00:00:00+09:00</published><updated>2019-12-26T00:00:00+09:00</updated><id>http://localhost:4000/aws_cli/aws_cli_basic</id><content type="html" xml:base="http://localhost:4000/aws_cli/aws_cli_basic/">&lt;h1 id=&quot;문서-목적&quot;&gt;문서 목적&lt;/h1&gt;

&lt;p&gt;이 문서는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-welcome.html&quot;&gt;AWS Command Line Interface 사용 설명서&lt;/a&gt;를 살펴보며 AWS CLI에 대한 학습했던 내용을 개인적으로 정리하기 위하여 작성되었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-welcome.html&quot;&gt;AWS Command Line Interface 사용 설명서&lt;/a&gt;에서 필요한 부분만 정리하였다.&lt;/p&gt;

&lt;p&gt;macOS로 진행하였고 이와 관련 된 것만 정리하였다.&lt;/p&gt;

&lt;h1 id=&quot;aws-cli란&quot;&gt;AWS CLI란?&lt;/h1&gt;

&lt;p&gt;AWS CLI는 Amazon Web Service Command Line Interface의 약자로 셸의 명령을 사용하여 AWS 서비스와 상호 작용할 수 있는 오픈 소스 도구이다.&lt;/p&gt;

&lt;p&gt;AWS Management 콘솔과 동일한 기능을 제공을 해준다. &lt;/p&gt;

&lt;p&gt; 자세한 내용은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-welcome.html&quot;&gt;AWS Command Line Interface이란 무엇입니까?&lt;/a&gt;를 참고한다.&lt;/p&gt;

&lt;h1 id=&quot;설치방법&quot;&gt;설치방법&lt;/h1&gt;

&lt;h2 id=&quot;macos&quot;&gt;macOS&lt;/h2&gt;

&lt;p&gt;다음과 같은 환경에서 AWS CLI 설치를 진행하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;macOS Mojave 버전 10.14.6(18G87)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AWS CLI를 설치하기 위하여 아래의 Python 버전이상이 설치 되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;2019. 8. 27 기준 &lt;/p&gt;

&lt;p&gt;Python 2 버전 2.6.5+ 또는 Python 3 버전 3.3+&lt;/p&gt;

&lt;p&gt;Python이 설치 되어있지 않다면 설치방법에 대하여 구글링을 하거나 다음과 같은 brew 명령을 활용하여 설치하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew intall python3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 설치 방법도 있지만 AWS CLI의 기본 배포 방법은 pip이며, 그중 pip3로 설치하는 것을 권장하고 있으므로 pip3로 설치를 진행한다.&lt;/p&gt;

&lt;p&gt;다음과 같이 AWS CLI를 설치를 진행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pip3 install awscli --upgrade --user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 명령으로 AWS CLI 설치 확인겸 버전 확인을 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws --version
aws-cli/1.16.222 Python/2.7.16 Darwin/18.7.0 botocore/1.12.212
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-install.html&quot;&gt;AWS CLI 설치 - macOS&lt;/a&gt;를 참고한다.&lt;/p&gt;

&lt;h2 id=&quot;다른-os&quot;&gt;다른 OS&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-install.html&quot;&gt;AWS CLI 설치&lt;/a&gt;에서 OS에 맞는 설치법으로 설치하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;구성-및-자격-증명-저장&quot;&gt;구성 및 자격 증명 저장&lt;/h1&gt;

&lt;p&gt;AWS CLI는 자주 사용하는 구성 및 자격 증명을 파일로 저장하여 관리할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;구성-및-자격-증명의-구조&quot;&gt;구성 및 자격 증명의 구조&lt;/h2&gt;

&lt;p&gt;구성 및 자격 증명은 다음과 같은 구조로 저장된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Users/user/.aws/
├── config
└── credentials
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각각의 파일에 담기는 내용은 다음과 같다.&lt;/p&gt;

&lt;p&gt;config&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;output : aws cli로 부터 응답을 받는 형식 (예 : json, text)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;region : aws region을 의미한다. region 코드표는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/general/latest/gr/rande.html&quot;&gt;AWS 서비스 엔드포인트&lt;/a&gt;를 참고하여 설정해주면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;credentials&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;aws_access_key_id : 액세스 키 아이디를 입력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;aws_secret_access_key : 시크릿 액세스 키를 입력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-configure-files.html&quot;&gt;구성 및 자격 증명 파일&lt;/a&gt;을 참고한다.&lt;/p&gt;

&lt;h2 id=&quot;프로필-파일&quot;&gt;프로필 파일&lt;/h2&gt;

&lt;p&gt;AWS CLI에서는 프로필 별로 구성 및 자격 증명을 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;프로필 별로 구성 및 자격증명을 지정하는 방법은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws configure --profile &quot;프로필명&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정된 프로필을 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat ~/.aws/config
[default]
region=us-west-2
output=json
[profile user1]
region=us-east-1
output=text
 
$ cat ~/.aws/credential
[default]
aws_access_key_id=&quot;디폴트 엑세스 키 아이디&quot;
aws_secret_access_key=&quot;디폴트 시크릿 엑세스 키&quot;
[프로필명]
aws_access_key_id=&quot;프로필명 엑세스 키 아이디&quot;
aws_secret_access_key=&quot;프로필명 시크릿 엑세스 키&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;aws-cli-사용--amazon-s3&quot;&gt;AWS CLI 사용 : Amazon S3&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-services-s3-commands.html&quot;&gt;AWS CLI에서 상위 수준(s3) 명령 사용&lt;/a&gt;을 참고하여 문서에서 기술한대로 동작하는 지 확인했다.&lt;/p&gt;

&lt;p&gt;각 명령어 별로 케이스 염두하여 테스트 하였다.&lt;/p&gt;

&lt;h3 id=&quot;cp-명령어&quot;&gt;cp 명령어&lt;/h3&gt;

&lt;p&gt;케이스 : 로컬 파일을 s3로 복사&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls
cp                local_cp_test.txt

$ aws s3 ls s3://bucket/user-s3-cli-test/
2019-08-22 21:10:50          0

$ aws s3 cp local_cp_test.txt s3://bucket/user-s3-cli-test/s3_cp_test.txt
upload: ./local_cp_test.txt to s3://bucket/user-s3-cli-test/s3_cp_test.txt

$ aws s3 ls s3://bucket/user-s3-cli-test/
2019-08-22 21:10:50          0
2019-08-22 22:23:05         21 s3_cp_test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;케이스 : s3 파일을 로컬로 복사&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls -al
total 16
drwxr-xr-x  3 user  staff    96  8 22 22:25 .
drwxr-xr-x  7 user  staff   224  8 22 20:59 ..
-rw-r--r--@ 1 user  staff  6148  8 22 22:19 .DS_Store

$ aws s3 ls s3://bucket/user-s3-cli-test/
2019-08-22 21:10:50          0
2019-08-22 22:23:05         21 s3_cp_test.txt

$ aws s3 cp s3://bucket/user-s3-cli-test/s3_cp_test.txt ./local_cp_test.txt
download: s3://bucket/user-s3-cli-test/s3_cp_test.txt to ./local_cp_test.txt

$ ls
local_cp_test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;케이스 : s3 파일을 s3로 복사&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://bucket/user-s3-cli-test/
2019-08-22 21:10:50          0
2019-08-22 22:23:05         21 s3_cp_test.txt

$ aws s3 cp s3://bucket/user-s3-cli-test/s3_cp_test.txt s3://bucket/user-s3-cli-test/s3_cp_test_copy.txt
copy: s3://bucket/user-s3-cli-test/s3_cp_test.txt to s3://bucket/user-s3-cli-test/s3_cp_test_copy.txt

$ aws s3 ls s3://bucket/user-s3-cli-test/
2019-08-22 21:10:50          0
2019-08-22 22:23:05         21 s3_cp_test.txt
2019-08-22 22:30:43         21 s3_cp_test_copy.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;케이스 : 로컬 디렉터리를 s3로 복사&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls ./cp_dir_test/
local_cp_test.txt

$ aws s3 ls s3://bucket/user-s3-cli-test/
2019-08-22 21:10:50          0
2019-08-22 22:23:05         21 s3_cp_test.txt
2019-08-22 22:30:43         21 s3_cp_test_copy.txt

$ aws s3 cp ./cp_dir_test s3://bucket/user-s3-cli-test/s3_cp_dir_test --recursive
upload: cp_dir_test/local_cp_test.txt to s3://bucket/user-s3-cli-test/s3_cp_dir_test/local_cp_test.txt

$ aws s3 ls s3://bucket/user-s3-cli-test/s3_cp_dir_test
                           PRE s3_cp_dir_test/

$ aws s3 ls s3://bucket/user-s3-cli-test/s3_cp_dir_test/
2019-08-22 22:34:48         21 local_cp_test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;lsmv-rm-명령&quot;&gt;ls, mv, rm 명령&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-services-s3-commands.html&quot;&gt;AWS CLI에서 상위 수준(s3) 명령 사용&lt;/a&gt;을 참고하여 테스트한다.&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-welcome.html&quot;&gt;AWS Command Line Interface 사용 설명서&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-install.html&quot;&gt;AWS CLI 설치&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-services-s3-commands.html&quot;&gt;AWS CLI에서 상위 수준(s3) 명령 사용&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="AWS_CLI" /><summary type="html">이 문서는 AWS Command Line Interface 사용 설명서를 살펴보며 AWS CLI에 대한 학습했던 내용을 개인적으로 정리하기 위하여 작성되었다.</summary></entry><entry><title type="html">JMeter 기본 사용법</title><link href="http://localhost:4000/test/jmeter_basic/" rel="alternate" type="text/html" title="JMeter 기본 사용법" /><published>2019-12-23T00:00:00+09:00</published><updated>2019-12-23T00:00:00+09:00</updated><id>http://localhost:4000/test/jmeter_basic</id><content type="html" xml:base="http://localhost:4000/test/jmeter_basic/">&lt;hr /&gt;

&lt;h1 id=&quot;jmeter란&quot;&gt;JMeter란?&lt;/h1&gt;

&lt;p&gt; JMeter는 java로 만들어진 성능 테스트 툴이다. 구매한 솔루션의 Spec을 확인하거나 서버의 스케일링을 위해 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;설치하기&quot;&gt;설치하기&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;oracle site ( &lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/index.html&lt;/a&gt; ) 에서 java (version : 8+) 을 다운받는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;java를 설치한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apach jmeter site( &lt;a href=&quot;https://jmeter.apache.org/download_jmeter.cgi&quot;&gt;https://jmeter.apache.org/download_jmeter.cgi&lt;/a&gt; ) 로 이동한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;binary file 을 다운받는다. ( zip 또는 tgz )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;압축을 푼다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;실행하기&quot;&gt;실행하기&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JMeter에는 GUI mode 와  CLI mode 가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GUI mode 에서는 test script를 만들 수 있고, test script를 실행할 수 있다. 하지만, load test는 GUI mode에서 하지 않는다. ( &lt;a href=&quot;https://jmeter.apache.org/usermanual/get-started.html&quot;&gt;https://jmeter.apache.org/usermanual/get-started.html&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;4 Running JMeter)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CLI mode 에서는 GUI mode에서 만든 test script( .jmx)를 이용하여 load test 를 수행할 수 있다.  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gui-mode&quot;&gt;GUI Mode&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;terminal을 실행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jmeter 압축을 푼 경로로 이동한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apache-jmeter-5.1 폴더로 이동한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java jar ./bin/ApacheJMeter.jar
 
or
 
sh ./bin/jmeter.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 명령을 입력하여 JMeter를 실행한다. &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cli-mode&quot;&gt;CLI Mode&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;terminal을 실행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jmeter 압축을 푼 경로로 이동한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apache-jmeter-5.1 폴더로 이동한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/jmeter -n -t [jmxfile].jmx -l [logfile].jtl -e -o [loadtest result path]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 명령어를 입력하면 jmx script file 을 이용하여 CLI mode로 실행한다.( -n : nongui, -t : testfile(.jmx), -l : logfile, -e : , -o :  )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CLI 모드에서 테스트하기 전에 GUI 모드에서 Thread group, Sampler, Listener 등을 설정할 script파일을 생성해야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;테스트-전-준비-사항&quot;&gt;테스트 전 준비 사항&lt;/h1&gt;

&lt;h2 id=&quot;목적-파악&quot;&gt;목적 파악&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;성능 테스트를 할 것인지, 부하 테스트를 할 것인지 목적을 설정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사내에는 스케일 아웃 조건을 파악하기 위해 테스트를 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;성능 테스트의 경우 Response time, TPS 등을 확인한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부하 테스트의 경우 서버가 다운되는 동시 접속량을 확인한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;테스트-수행&quot;&gt;테스트 수행&lt;/h1&gt;

&lt;h2 id=&quot;테스트-플랜-설정하기&quot;&gt;테스트 플랜 설정하기&lt;/h2&gt;

&lt;h3 id=&quot;thread-group-생성&quot;&gt;Thread group 생성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Number of Threads : 테스트할 서버로 접속을 시도하는 사용자의 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Lamp-Up Period : 사용자간 접속을 요청하는 간격&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Loop count : 사용자마다 요청 하는 횟수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Number of Threads, Lamp-Up Period, Loop count를 설정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예를 들어 Lamp-Up Period를 2로 설정했다면 첫 번째 사용자가 접속 요청후 2초 후 두 번째 사용자가 접속 요청을 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Number of Threads * Loop count = 총 요청 횟수 이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;접속을 계속 시도하고 싶은 경우 Loop count를 Forever로 체크하면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sampler-생성&quot;&gt;Sampler 생성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;사용자의 행동을 대행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;API test의 경우 HTTP Request를 사용한다. ( API는 http로 호출하기 때문.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Request에서 protocol, ip, port, method, path, body data( POST일 경우 )을 설정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Reqeust를 보낼때 json형식으로 보내야 된다면, HTTP Header Manager 를 추가하고 설정한다.( Thread Group 오른쪽 마우스 클릭 -&amp;gt; config element -&amp;gt; HTTP Header Manager) &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;listener-생성&quot;&gt;Listener 생성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;처리 상황 및 결과를 데이터나 그래프로 보여준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응답시간이 필요한 경우 Plugin으로 Response Times Over Time을 설치하여 사용한다.( &lt;a href=&quot;https://jmeter-plugins.org/wiki/ResponseTimesOverTime/&quot;&gt;https://jmeter-plugins.org/wiki/ResponseTimesOverTime&lt;/a&gt; )&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;참조-사이트&quot;&gt;참조 사이트&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Apache get started ( &lt;a href=&quot;https://jmeter.apache.org/usermanual/get-started.html&quot;&gt;https://jmeter.apache.org/usermanual/get-started.html&lt;/a&gt; )&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="JMeter" /><category term="Test" /><summary type="html"> JMeter는 java로 만들어진 성능 테스트 툴이다. 구매한 솔루션의 Spec을 확인하거나 서버의 스케일링을 위해 사용한다.</summary></entry><entry><title type="html">AWS Chalice - Tutorial 기초 학습 정리</title><link href="http://localhost:4000/lambda/chalice_tutorial/" rel="alternate" type="text/html" title="AWS Chalice - Tutorial 기초 학습 정리" /><published>2019-12-22T00:00:00+09:00</published><updated>2019-12-22T00:00:00+09:00</updated><id>http://localhost:4000/lambda/chalice_tutorial</id><content type="html" xml:base="http://localhost:4000/lambda/chalice_tutorial/">&lt;h1 id=&quot;목적&quot;&gt;목적&lt;/h1&gt;

&lt;p&gt;이 문서는 &lt;a href=&quot;https://github.com/aws/chalice&quot;&gt;AWS Chalice Github README 문서&lt;/a&gt;를 학습하며 개인적인 학습정리를 위하여 작성되었다.&lt;/p&gt;

&lt;p&gt;문서의 내용을 따라한 내용들을 정리한 내용이 주를 이루며 추후 학습이 더 필요한 부분은 그린으로 표시하였다.&lt;/p&gt;

&lt;h1 id=&quot;테스트-환경&quot;&gt;테스트 환경&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;OS : macOS Mojave 10.14.6&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Chalice 1.11.0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python 3.6.5&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;darwin 18.7.0&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;학습에-필요한-사전-정보&quot;&gt;학습에 필요한 사전 정보&lt;/h1&gt;

&lt;h2 id=&quot;aws-lambda&quot;&gt;AWS Lambda&lt;/h2&gt;

&lt;p&gt;다음과 같은 문서의 내용의 숙지가 선행되어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/with-userapp.html&quot;&gt;https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/with-userapp.html&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/getting-started-create-function.html&quot;&gt;https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/getting-started-create-function.html&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;

&lt;p&gt;원할한 테스트를 위하여 다음과 같이 http 라이브러리를 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pip install http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;curl&quot;&gt;CURL&lt;/h2&gt;

&lt;p&gt;원할한 테스트를 위하여 다음과 같이 curl 라이브러리를 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew install curl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;학습-진행&quot;&gt;학습 진행&lt;/h1&gt;

&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;

&lt;p&gt;다음과 같이 Quick start를 위한 디렉터리를 구성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir chalice-demo
$ cd chlice-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 Virtual env를 구성하고 활성화 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ virtualenv --python=3.6 .venv
$ source .venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Chalice를 설치하고, chalice 프로젝트를 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pip install chalice
$ chalice new-project andro-test-chalice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-local-mode&quot;&gt;Tutorial: Local Mode&lt;/h2&gt;

&lt;p&gt;로컬 빌드를 위하여 다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice

app = Chalice(app_name='helloworld')


@app.route('/')
def index():
    return {'hello': 'world'}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 명령어로 로컬 빌드를 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ chalice local --port=8080
Restarting local dev server.
Serving on http://127.0.0.1:8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 명령어로 로컬 빌드의 동작을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ http localhost:8080
HTTP/1.1 200 OK
Content-Length: 17
Content-Type: application/json
Date: Tue, 17 Sep 2019 06:12:51 GMT
Server: BaseHTTP/0.6 Python/3.6.5

{
    &quot;hello&quot;: &quot;world&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;deploying&quot;&gt;Deploying&lt;/h2&gt;

&lt;p&gt;배포를 위하여 다음과 같이 config.json 파일을 수정한다.
{iam_role_arn}은 각자 람다 사용을 위해 생성한 iam의 arn를 입력한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim .chalice/config.json
{
  &quot;version&quot;: &quot;2.0&quot;,
  &quot;app_name&quot;: &quot;andro-test-chalice&quot;,
  &quot;api_gateway_stage&quot;: &quot;api&quot;,
  &quot;lambda_timeout&quot;: 120,
  &quot;lambda_memory_size&quot;: 1024,
  &quot;stages&quot;: {
    &quot;qa&quot;: {
      &quot;api_gateway_stage&quot;: &quot;qa&quot;,
      &quot;autogen_policy&quot;: false,
      &quot;iam_role_arn&quot;: &quot;{iam_role_arn}&quot;
    },
    &quot;prod&quot;: {
      &quot;api_gateway_stage&quot;: &quot;prod&quot;,
      &quot;autogen_policy&quot;: false,
      &quot;iam_role_arn&quot;: &quot;{iam_role_arn}&quot;
    }
  },
  &quot;manage_iam_role&quot;:false,
  &quot;iam_role_arn&quot;:&quot;{iam_role_arn}&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 배포한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ chalice deploy
Creating deployment package.
Updating lambda function: andro-test-chalice-dev
Updating rest API
Resources deployed:
  - Lambda ARN: 
  - Rest API URL: {lambda_url}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포된 lambda가 동작하는지 다음과 같이 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XGET {lambda_url}
{&quot;hello&quot;:&quot;world&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-url-parameters&quot;&gt;Tutorial: URL Parameters&lt;/h2&gt;

&lt;p&gt;경로에 따라 다르게 보이기 위하여 다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice

app = Chalice(app_name='helloworld')

CITIES_TO_STATE = {
    'seattle': 'WA',
    'portland': 'OR',
}


@app.route('/')
def index():
    return {'hello': 'world'}

@app.route('/cities/{city}')
def state_of_city(city):
    return {'state': CITIES_TO_STATE[city]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda가 동작하는지 다음과 같이 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XGET {lambda_url}
{&quot;hello&quot;:&quot;world&quot;}%

$ curl -XGET {lambda_url}cities/seattle
{&quot;state&quot;:&quot;WA&quot;}%

$ curl -XGET {lambda_url}cities/portland
{&quot;state&quot;:&quot;OR&quot;}%

$ curl -XGET {lambda_url}cities/vancouver
{&quot;Code&quot;:&quot;InternalServerError&quot;,&quot;Message&quot;:&quot;An internal server error occurred.&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-error-messages&quot;&gt;Tutorial: Error Messages&lt;/h2&gt;

&lt;p&gt;에러가 발생하였을 때 처리하기 위하여는 디버그 모드를 활성화 해야한다.&lt;/p&gt;

&lt;p&gt;또한 에러가 발생할 것으로 예측되는 함수나 구문에서 try~except 구문으로 예외처리한다.&lt;/p&gt;

&lt;p&gt;위의 app.py를 다음과 같이 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice
from chalice import BadRequestError

app = Chalice(app_name='helloworld')
app.debug = True

CITIES_TO_STATE = {
    'seattle': 'WA',
    'portland': 'OR',
}


@app.route('/')
def index():
    return {'hello': 'world'}


@app.route('/cities/{city}')
def state_of_city(city):
    try:
        return {'state': CITIES_TO_STATE[city]}
    except KeyError:
        raise BadRequestError(&quot;Unknown city '%s', valid choices are: %s&quot; % (
            city, ', '.join(CITIES_TO_STATE.keys())))


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda가 동작하는지 다음과 같이 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XGET {lambda_url}
{&quot;hello&quot;:&quot;world&quot;}%

$ curl -XGET {lambda_url}cities/seattle
{&quot;state&quot;:&quot;WA&quot;}%

$ curl -XGET {lambda_url}cities/portland
{&quot;state&quot;:&quot;OR&quot;}%

$ curl -XGET {lambda_url}cities/vancouver
{&quot;Code&quot;:&quot;BadRequestError&quot;,&quot;Message&quot;:&quot;BadRequestError: Unknown city 'vancouver', valid choices are: seattle, portland&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-additional-routing&quot;&gt;Tutorial: Additional Routing&lt;/h2&gt;

&lt;p&gt;GET method이외에 PUT, POST를 추가해본다.&lt;/p&gt;

&lt;p&gt;데코레이션 /myview는 method에 따라 다른 응답을 제공하고자 한다.&lt;/p&gt;

&lt;p&gt;다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice

app = Chalice(app_name='helloworld')


@app.route('/')
def index():
    return {'hello': 'world'}


@app.route('/resource/{value}', methods=['PUT'])
def put_test(value):
    return {&quot;value&quot;: value}


@app.route('/myview/{value}', methods=['POST'])
def myview_post(value):
    return {&quot;value&quot;: value, &quot;method&quot;, &quot;post&quot;}


@app.route('/myview/{value}', methods=['PUT'])
def myview_put(value):
    return {&quot;value&quot;: value, &quot;method&quot;, &quot;put&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda가 동작하는지 다음과 같이 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XPUT {lambda_url}/resource/foo
{&quot;value&quot;:&quot;foo&quot;}%

$ curl -XPUT {lambda_url}/myview/foo
{&quot;value&quot;:&quot;foo&quot;,&quot;mothod&quot;:&quot;put&quot;}%

$ curl -XPOST {lambda_url}/myview/foo
{&quot;value&quot;:&quot;foo&quot;,&quot;mothod&quot;:&quot;post&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-request-metadata&quot;&gt;Tutorial: Request Metadata&lt;/h2&gt;

&lt;p&gt;메타데이터를 활용하기 위한 섹터이다.&lt;/p&gt;

&lt;p&gt;우선 메소드 종류에 따라 다른 응답을 위하여 다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice
from chalice import NotFoundError

app = Chalice(app_name='helloworld')


@app.route('/')
def index():
    return {'hello': 'world'}


OBJECTS = {
}


@app.route('/objects/{key}', methods=['GET', 'PUT'])
def myobject(key):
    request = app.current_request
    if request.method == 'PUT':
        OBJECTS[key] = request.json_body
    elif request.method == 'GET':
        try:
            return {key: OBJECTS[key]}
        except KeyError:
            raise NotFoundError(key)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda의 동작을 확인하기 위하여 다음과 같이 커널 명령으로 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XGET {lambda_url}/objects/banana
{&quot;Code&quot;:&quot;NotFoundError&quot;,&quot;Message&quot;:&quot;NotFoundError: banana&quot;}%

$ curl -X PUT -H &quot;Content-Type: application/json; charset=utf-8&quot; -d '&quot;yellow&quot;' {lambda_url}/objects/banana
null%

$ curl -XGET {lambda_url}/objects/banana
{&quot;banana&quot;:&quot;yellow&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 app.current_request 인스턴스에 관하여 다음과 같은 속성들이 존재하고 속성들에 대한 설명은 &lt;a href=&quot;https://github.com/aws/chalice/tree/1791175cb30eaa3fd89a177e21dbba654d352b0c&quot;&gt;Github AWS-Chalice README 페이지&lt;/a&gt;를 참고한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.query_params&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.headers&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.uri_params&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.method&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.json_body&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.raw_body&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.context&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current_request.stage_vars&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;current_request.to_dict()를 이용하여 메타데이터를 확인하기 위하여 다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice

app = Chalice(app_name='helloworld')


@app.route('/')
def index():
    return {'hello': 'world'}


@app.route('/introspect')
def introspect():
    return app.current_request.to_dict()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda의 동작을 확인하기 위하여 다음과 같이 커널 명령으로 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ http '{lambda_url}/introspect?query1=value1&amp;amp;query2=value2' 'X-TestHeader: Foo'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-request-content-types&quot;&gt;Tutorial: Request Content Types&lt;/h2&gt;

&lt;p&gt;컨텐트 타입에 따른 응답을 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;app.py를 다음과 같이 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys

from chalice import Chalice
if sys.version_info[0] == 3:
    # Python 3 imports.
    from urllib.parse import urlparse, parse_qs
else:
    # Python 2 imports.
    from urlparse import urlparse, parse_qs


app = Chalice(app_name='helloworld')


@app.route('/', methods=['POST'],
           content_types=['application/x-www-form-urlencoded'])
def index():
    parsed = parse_qs(app.current_request.raw_body.decode())
    return {
        'states': parsed.get('states', [])
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda는 다음과 같이 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### Content-Type application/json
$ http POST {lambda_url} states=WA states=CA --debug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### ContentType application/x-www-form-urlencoded
$ http --form POST {lambda_url} states=WA states=CA --debug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;-form은 Content-Type 헤더를 application/x-www-form-urlencoded로 세팅하는 것의 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;app.current_request.json_body는 ContentType application/json에서 정상적인 dict 객체가 존재하고, ContentType application/json 아닐 경우는 None이다.&lt;/p&gt;

&lt;h2 id=&quot;tutorial-customizing-the-http-response&quot;&gt;Tutorial: Customizing the HTTP Response&lt;/h2&gt;

&lt;p&gt;커스터 마이징한 응답으로 응답할 수 있다.&lt;/p&gt;

&lt;p&gt;app.py를 다음과 같이 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice, Response

app = Chalice(app_name='custom-response')


@app.route('/')
def index():
    return Response(body='hello world!',
                    status_code=200,
                    headers={'Content-Type': 'text/plain'})
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포된 lambda는 다음과 같이 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ http {lambda_url}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-gzip-compression-for-json&quot;&gt;Tutorial: GZIP compression for json&lt;/h2&gt;

&lt;p&gt;이 섹터는 사용빈도가 낮을 것으로 판단되어 스킵한다.&lt;/p&gt;

&lt;h2 id=&quot;tutorial-cors-support&quot;&gt;Tutorial: CORS Support&lt;/h2&gt;

&lt;p&gt;이 섹터는 전반적으로 추후 내용 보충이 필요하다.&lt;/p&gt;

&lt;p&gt;CORS(Cross-Origin Resource Share)의 개념은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS&quot;&gt;HTTP 접근 (CORS)&lt;/a&gt;을 참고하면 된다.&lt;/p&gt;

&lt;p&gt;다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import CORSConfig

cors_config = CORSConfig(
    allow_origin='https://foo.example.com',
    allow_headers=['X-Special-Header'],
    max_age=600,
    expose_headers=['X-Special-Header'],
    allow_credentials=True
)

@app.route('/custom_cors', methods=['GET'], cors=cors_config)
def supports_custom_cors():
    return {'cors': True}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포한 lambda를 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ http {lambda_url}custom_cors
HTTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Headers: Authorization,Content-Type,X-Amz-Date,X-Amz-Security-Token,X-Api-Key,X-Special-Header
Access-Control-Allow-Origin: https://foo.example.com
Access-Control-Expose-Headers: X-Special-Header
Access-Control-Max-Age: 600
...
중략
...

{
    &quot;cors&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice, Response

app = Chalice(app_name='multipleorigincors')

_ALLOWED_ORIGINS = set([
    'http://allowed1.example.com',
    'http://allowed2.example.com',
])


@app.route('/cors_multiple_origins', methods=['GET', 'OPTIONS'])
def supports_cors_multiple_origins():
    method = app.current_request.method
    if method == 'OPTIONS':
        headers = {
            'Access-Control-Allow-Method': 'GET,OPTIONS',
            'Access-Control-Allow-Origin': ','.join(_ALLOWED_ORIGINS),
            'Access-Control-Allow-Headers': 'X-Some-Header',
        }
        origin = app.current_request.headers.get('origin', '')
        if origin in _ALLOWED_ORIGINS:
            headers.update({'Access-Control-Allow-Origin': origin})
        return Response(
            body=None,
            headers=headers,
        )
    elif method == 'GET':
        return 'Foo'

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포한 lambda를 확인하면 다음과 같다. Access-Control-Allow-*를 살펴보면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ http OPTIONS {lambda_url}cors_multiple_origins
HTTP/1.1 200 OK
Access-Control-Allow-Headers: X-Some-Header
Access-Control-Allow-Method: GET,OPTIONS
Access-Control-Allow-Origin: http://allowed2.example.com,http://allowed1.example.com
...
중략
...

null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tutorial-policy-generation&quot;&gt;Tutorial: Policy Generation&lt;/h2&gt;

&lt;p&gt;다음과 같이 app.py를 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import json
import boto3
from botocore.exceptions import ClientError

from chalice import NotFoundError, Chalice

app = Chalice(app_name=&quot;boto3_test&quot;)

S3 = boto3.client('s3', region_name='us-east-1')
BUCKET = {bucket}
PATH = 'andro-chalice-test'


@app.route('/objects/{key}', methods=['GET', 'PUT'])
def s3objects(key):
    fullpath_key = &quot;/&quot;.join([PATH, key])
    request = app.current_request
    if request.method == 'PUT':
        S3.put_object(Bucket=BUCKET, Key=fullpath_key,
                      Body=json.dumps(request.json_body))
    elif request.method == 'GET':
        try:
            response = S3.get_object(Bucket=BUCKET, Key=fullpath_key)
            return json.loads(response['Body'].read())
        except ClientError as e:
            raise NotFoundError(key)



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로컬 빌드나 배포하여 확인하나 기능상 차이가 없기에 로컬 빌드로 확인한다. 로컬로 빌드한다.&lt;/p&gt;

&lt;p&gt;다음과 같이 로컬 chalice의 동작을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo '{&quot;foo&quot;:&quot;bar&quot;}' | http PUT localhost:8080/objects/banana
HTTP/1.1 200 OK
Content-Length: 4
Content-Type: application/json
Date: Tue, 17 Sep 2019 06:38:28 GMT
Server: BaseHTTP/0.6 Python/3.6.5

null

$ http localhost:8080/objects/banana
HTTP/1.1 200 OK
Content-Length: 13
Content-Type: application/json
Date: Tue, 17 Sep 2019 06:38:33 GMT
Server: BaseHTTP/0.6 Python/3.6.5

{
    &quot;foo&quot;: &quot;bar&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;aws cli로 실제 버킷에 저장되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ s3 ls s3://{s3_address}/andro-chalice-test --recursive
2019-09-17 15:38:28         14 andro-chalice-test/banana
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포한다.&lt;/p&gt;

&lt;p&gt;배포한 lambda의 동작을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo '&quot;red&quot;' | http PUT {lambda_url}objects/apple
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 4
Content-Type: application/json
...
하략

null

$ http {lambda_url}objects/apple
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 3
Content-Type: application/json
Date: Tue, 17 Sep 2019 07:13:51 GMT
...
하략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;수동으로 정책을 제공할 수 있다. 다음과 같은 경로에 정책에 관하여 정의해주면 된다. 이 부분은 추후 학습하여 수정할 예정이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;projectdir&amp;gt;/.chalice/policy.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예) andro-chalice-test/policy-dev.json&lt;/p&gt;

&lt;h2 id=&quot;tutorial-using-custom-authentication&quot;&gt;Tutorial: Using Custom Authentication&lt;/h2&gt;

&lt;p&gt;문서에서 소개하는 인증방법은 다음과 같고, 이 중 Cognito User Pools를 제외한 내용을 실습한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;API Key&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS IAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cognito User Pools&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Custom Auth Handler&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;app.py를 다음과 같이 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from chalice import Chalice, IAMAuthorizer, CustomAuthorizer

app = Chalice(app_name=&quot;boto3_test&quot;)

iam_authorizer = IAMAuthorizer()
custom_authorizer = CustomAuthorizer(
    'MyCustomAuth', header='Authorization',
    authorizer_uri=('arn:aws:apigateway:region:lambda:path/2015-03-31'
                    '/functions/arn:aws:lambda:region:account-id:'
                    'function:FunctionName/invocations'))


@app.route('/authenticated', methods=['GET'], api_key_required=True)
def authenticated():
    return {&quot;secure&quot;: True}


@app.route('/iam-role', methods=['GET'], authorizer=iam_authorizer)
def authenticated():
    return {&quot;secure&quot;: True}


@app.route('/custom-auth', methods=['GET'], authorizer=custom_authorizer)
def authenticated():
    return {&quot;secure&quot;: True}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 로컬 chalice의 동작을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ http localhost:8080/authenticated
HTTP/1.1 200 OK
Content-Length: 15
Content-Type: application/json
Date: Tue, 17 Sep 2019 08:57:24 GMT
Server: BaseHTTP/0.6 Python/3.6.5
{
    &quot;secure&quot;: true
}


$ http localhost:8080/iam-role
HTTP/1.1 200 OK
Content-Length: 15
Content-Type: application/json
Date: Tue, 17 Sep 2019 08:57:35 GMT
Server: BaseHTTP/0.6 Python/3.6.5
{
    &quot;secure&quot;: true
}


$ http localhost:8080/custom-auth
HTTP/1.1 200 OK
Content-Length: 15
Content-Type: application/json
Date: Tue, 17 Sep 2019 08:57:40 GMT
Server: BaseHTTP/0.6 Python/3.6.5

{
    &quot;secure&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Chalice 기본 학습 공유&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Lambda" /><category term="AWS_Chalice" /><summary type="html">이 문서는 AWS Chalice Github README 문서를 학습하며 개인적인 학습정리를 위하여 작성되었다.</summary></entry><entry><title type="html">PyTest 프레임워크 기초 사용법</title><link href="http://localhost:4000/test/pytest_basic/" rel="alternate" type="text/html" title="PyTest 프레임워크 기초 사용법" /><published>2019-12-20T00:00:00+09:00</published><updated>2019-12-20T00:00:00+09:00</updated><id>http://localhost:4000/test/pytest_basic</id><content type="html" xml:base="http://localhost:4000/test/pytest_basic/">&lt;h1 id=&quot;목적&quot;&gt;목적&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;이 문서는 Pytest framework에 관하여 학습한 내용을 정리하기 위해 작성되었다.&lt;/p&gt;

&lt;p&gt;Pytest &lt;a href=&quot;https://docs.pytest.org/en/latest/example/index.html&quot;&gt;공식 가이드 문서&lt;/a&gt; 내용 중 아래의 카테고리에 해당하는 내용을 정리했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/assert.html#assert&quot;&gt;Asserting with the assert statement&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/fixture.html#fixtures&quot;&gt;pytest fixtures: explicit, modular, scalable&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/parametrize.html#parametrize&quot;&gt;Parametrizing fixtures and test functions&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;학습-환경&quot;&gt;학습 환경&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;학습 환경은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Python 버전 : 3.7.4&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PyTest 버전 : 5.2.1&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;환경-구성&quot;&gt;환경 구성&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;다음과 같이 가상환경을 구성하고 활성화한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir pytest_tutorial
$ cd pytest_tutorial
$ virtualenv --python=python3.7 .venv
$ source .venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 명령어를 입력해 Pytest 모듈을 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pip install pytest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;pytest-실행-및-실행-결과-설명&quot;&gt;Pytest 실행 및 실행 결과 설명&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;테스트-코드-실행하는-방법&quot;&gt;테스트 코드 실행하는 방법&lt;/h2&gt;

&lt;p&gt;다음과 같은 명령어를 입력 할 경우 실행된 디렉토리 안에서 Pytest가 정해진 규칙에 따라 Test 함수를 찾아 실행하게 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pytest가 어떤 규칙을 통해 Testcode를 찾아 실행하는 지에 대한 자세한 내용은 &lt;a href=&quot;https://docs.pytest.org/en/latest/goodpractices.html#test-discovery&quot;&gt;문서&lt;/a&gt;를 클릭하면 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;사용자가-지정한-규칙에-해당하는-테스트-코드-실행하는-방법&quot;&gt;사용자가 지정한 규칙에 해당하는 테스트 코드 실행하는 방법&lt;/h2&gt;

&lt;p&gt;여러 개의 파일로 이루어진 테스트 코드를 테스트 하고자 한다면 와일드 카드(*)나 디렉터리 지정, 모듈 지정 등을 활용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 와일드 카드 활용
$ pytest test_*.py

# 모듈 지정
$ pytest mymodule

# 현재 디렉터리 지정
$ pytest ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 2개의 테스트 코드 test_sample_1.py, test_sample_2.py를 입력한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def func(x):
    return x + 1

def test_answer1():
    assert func(3) == 5 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def func(x):
    return x * 2

def test_answer2():
    assert func(3) == 6 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2개의 테스트 코드(test_sample_1.py, test_sample_2.py)를 실행하기 위하여 test_sample_*로 지정하여 테스트를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_sample_*
==================================== test session starts ====================================
platform darwin -- Python 3.7.4, pytest-5.1.1, py-1.8.0, pluggy-0.12.0
rootdir: /Users/kevin/dev/pytest_tutorial
collected 2 items

test_sample_1.py F                                                                    [ 50%]
test_sample_2.py .                                                                    [100%]

========================================= FAILURES ==========================================
_______________________________________ test_answer1 ________________________________________

    def test_answer1():
&amp;gt;       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)

test_sample_1.py:6: AssertionError
================================ 1 failed, 1 passed in 0.07s ================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 결과를 통해 지정한 테스트 코드가 정상적으로 실행되었음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;참고한 문서는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/goodpractices.html#good-integration-practices&quot;&gt;https://docs.pytest.org/en/latest/goodpractices.html#good-integration-practices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;assert-기능과-pytest-실행-결과-설명&quot;&gt;Assert 기능과 Pytest 실행 결과 설명&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;assert 기능을 테스트 하기 위해 다음과 같은 테스트 코드를 입력한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def func(x):
    return x + 1

def test_answer():
    assert func(3) == 5 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pytest framework는 이름의 prefix가 “test”인 함수만 인식하여 테스트 한다. 더 자세한 내용은 &lt;a href=&quot;https://docs.pytest.org/en/latest/goodpractices.html#test-discovery&quot;&gt;Conventions for Python test discovery&lt;/a&gt;에서 확인한다.&lt;/p&gt;

&lt;p&gt;test_answer를 실행하여 func(3)의 값과 5를 같은지 비교하고 같지 않다면 AssertionError를 발생시킨다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_sample.py
==================================== test session starts ====================================
platform darwin -- Python 3.7.4, pytest-5.1.1, py-1.8.0, pluggy-0.12.0
rootdir: /Users/kevin/dev/pytest_tutorial
collected 1 item
 
test_sample.py F                                                                      [100%]
 
========================================= FAILURES ==========================================
________________________________________ test_answer ________________________________________
 
    def test_answer():
&amp;gt;       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)
 
test_sample.py:6: AssertionError
===================================== 1 failed in 0.04s =====================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과를 설명하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;collected 2 item&lt;/em&gt; : 2개의 테스트 코드가 수집되었다는 것을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;test_sample_1.py F&lt;/em&gt; : test_sample_1.py에 있는 테스트 함수가 테스트 실패(F) 했음을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;test_sample_2.py . &lt;/em&gt;: test_sample_2.py에 있는 테스트 함수가 테스트 통과(.) 했음을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;== …중략… == FAILURES == …중략… ==&lt;/em&gt; : 테스트 통과 실패한 테스트 코드에 대하여 설명한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;def test_answer1()_부터&lt;/em&gt; Assertion Error_까지의 내용: 실제 func(3) 결과값은 4이고 기대값은 5이기 때문에 AssertionError가 발생하였음을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고한 문서는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/getting-started.html#create-your-first-test&quot;&gt;https://docs.pytest.org/en/latest/getting-started.html#create-your-first-test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;asserterror-발생-시-출력되는-메시지&quot;&gt;AssertError 발생 시 출력되는 메시지&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;asserterror시-출력되는-메세지-추가하기&quot;&gt;AssertError시 출력되는 메세지 추가하기&lt;/h2&gt;

&lt;p&gt;Pytest framework로 테스트 실패 시 출력되는 메세지를 추가할 수가 있다.&lt;/p&gt;

&lt;p&gt;다음과 같이 짝수이면 테스트 통과하는 테스트 코드를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def test_even():
    a = 11
    assert a % 2 == 0, &quot;value was odd, should be even&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 결과는 다음과 같다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_sample.py
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.1.1, py-1.8.0, pluggy-0.12.0
rootdir: /Users/kevin/dev/pytest_tutorial
collected 1 item                                                                                                                                                                                                                            

test_sample.py F                                                                                                                                                                                                                      [100%]

================================================================================================================= FAILURES ==================================================================================================================
_________________________________________________________________________________________________________________ test_even _________________________________________________________________________________________________________________

    def test_even():
        a = 11
&amp;gt;       assert a % 2 == 0, &quot;value was odd, should be even&quot;
E       AssertionError: value was odd, should be even
E       assert (11 % 2) == 0

test_sample.py:10: AssertionError
============================================================================================================= 1 failed in 0.05s =============================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과에서 에러 메시지 중 ”value was odd, should be even”가 출력된 것을 통해 추가한 오류 메시지가 정상 출력된 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 참고한 문서이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/goodpractices.html#good-integration-practices&quot;&gt;https://docs.pytest.org/en/latest/goodpractices.html#good-integration-practices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asserterror시-출력되는-메세지-변경하기&quot;&gt;AssertError시 출력되는 메세지 변경하기&lt;/h2&gt;

&lt;p&gt;PyTest는 테스트 통과 실패시 아래 예시와 같은 형태로 테스트 통과 실패 이유를 알려준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;========================================= FAILURES ==========================================
________________________________________ test_answer ________________________________________
 
    def test_answer():
&amp;gt;       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)
 
test_sample.py:6: AssertionError
===================================== 1 failed in 0.04s =====================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단한 테스트는 테스트 통과 실패 이유를 쉽게 찾을 수 있지만, 테스트 코드가 복잡해지거나 테스트 수가 많아진다면 테스트 통과 실패 이유를 확인하는 데에 많은 시간이 소모된다.&lt;/p&gt;

&lt;p&gt;따라서 테스트 통과 실패 이유를 직관적으로 출력할 수 있다면 테스트 통과 실패 이유를 확인하는 데에 적은 시간을 소모할 수 있을 것이라 판단된다.&lt;/p&gt;

&lt;p&gt;PyTest에서는 AssertionError 메세지를 변경하는 방법이 있다.&lt;/p&gt;

&lt;p&gt;pytest_assertrepr_compare 함수에 AssertionError 출력 메세지를 작성하는 방법이다.&lt;/p&gt;

&lt;p&gt;pytest_assertrepr_compare 함수를 작성하여 AssertionError 메세지를 작성해보자.&lt;/p&gt;

&lt;p&gt;우선 테스트 코드와 동일한 디렉터리 레벨에 conftest.py를 생성하고 다음과 같이 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from test_foocompare import Foo

def pytest_assertrepr_compare(op, left, right):
    if isinstance(left, Foo) and isinstance(right, Foo) and op == &quot;==&quot;:
        return [
            &quot;Comparing Foo instances:&quot;,
            &quot;   vals: {} != {}&quot;.format(left.val, right.val),
        ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pytest_assertrepr_compare 함수에 대하여 설명하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;AssertionError가 발생하였을 때, Assert문의 코드는 pytest_assertrepr_compare함수에 3개의 인자로 전달된다.&lt;/p&gt;

&lt;p&gt;예를 들면 &lt;em&gt;assert foo(1) == foo(2)&lt;/em&gt; 와 같은 코드에서 AssertionError가 발생한다면 pytest_assertrepr_compare 함수 인자로 op = “==”, left = foo(1), right=foo(2)가 전달 된다.&lt;/p&gt;

&lt;p&gt;left가 Foo클래스의 인스턴스이고, right가 Foo클래스의 인스턴스이며, 연산자(op)가 “==”을 만족한다면 AssertionError 메세지를 ”Comparing Foo instances:”, “ vals: {} != {}”.format(left.val, right.val) 형태로 출력하겠다는 의미이다.&lt;/p&gt;

&lt;p&gt;테스트를 위하여 test_foocompare.py를 생성하고 다음과 같이 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Foo:
    def __init__(self, val):
        self.val = val

    def __eq__(self, other):
        return self.val == other.val


def test_compare():
    f1 = Foo(1)
    f2 = Foo(2)
    assert f1 == f2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PyTest framework로 test_foocompare.py를 실행하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_foocompare.py      
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /Users/kevin/dev/pytest_tutorial/assert
collected 1 item                                                                                                                                                                                                                            

test_foocompare.py F                                                                                                                                                                                                                  [100%]

================================================================================================================= FAILURES ==================================================================================================================
_______________________________________________________________________________________________________________ test_compare ________________________________________________________________________________________________________________

    def test_compare():
        f1 = Foo(1)
        f2 = Foo(2)
&amp;gt;       assert f1 == f2
E       assert Comparing Foo instances:
E            vals: 1 != 2

test_foocompare.py:12: AssertionError
============================================================================================================= 1 failed in 0.04s =============================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AssertionError가 발생한 코드 아래에 테스트 실패 이유가 conftest.py에 작성한 메세지 형태(&lt;em&gt;“Comparing Foo instances:”, “ vals: {} != {}”.format(left.val, right.val)&lt;/em&gt;)로 출력된다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 참고한 문서이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/assert.html#defining-your-own-explanation-for-failed-assertions&quot;&gt;https://docs.pytest.org/en/latest/assert.html#defining-your-own-explanation-for-failed-assertions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exceptionerror-발생-테스트하기&quot;&gt;ExceptionError 발생 테스트하기&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;테스트할 대상에 의도적으로 ExceptionError를 발생시키는 인자를 입력하여 ExceptionError가 발생하는지 테스트 해야 하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;만약 ExceptionError를 발생시키는 인자를 입력하여 ExceptionError가 발생하면 ExceptionError가 발생한 테스트 코드 아래의 코드들은 실행되지 않는다.&lt;/p&gt;

&lt;p&gt;ExceptioError 발생하는 코드를 try…catch…except로 감싸고 테스트하면 테스트 할 수 있다.&lt;/p&gt;

&lt;p&gt;PyTest framework의 pytest.raises 함수를 이용하면 편리하게 ExceptionError를 발생하는 상황을 테스트 할 수 있다.&lt;/p&gt;

&lt;p&gt;with 문과 pytest.raise 함수를 사용하여 ExceptionError가 발생하는 케이스를 테스트한다.&lt;/p&gt;

&lt;p&gt;테스트를 위하여 test_exception_zero_division.py를 생성하고 다음과 같은 코드를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pytest


def test_zero_division_1():
    with pytest.raises(ZeroDivisionError):
        1 / 0


def test_zero_division_2():
    with pytest.raises(ZeroDivisionError):
        1 / 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PyTest framework로 테스트 코드를 실행하고 결과를 확인한다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_exception_zero_division.py
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /Users/kevin/dev/pytest_tutorial
collected 2 items                                                                                                                                                                                                                           

test_sample.py .F                                                                                                                                                                                                                     [100%]

================================================================================================================= FAILURES ==================================================================================================================
___________________________________________________________________________________________________________ test_zero_division_2 ____________________________________________________________________________________________________________

    def test_zero_division_2():
        with pytest.raises(ZeroDivisionError):
&amp;gt;           1 / 2
E           Failed: DID NOT RAISE &amp;lt;class 'ZeroDivisionError'&amp;gt;

test_sample.py:23: Failed
======================================================================================================== 1 failed, 1 passed in 0.06s ========================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;test_zero_division_1 함수는 Divide Zero ExceptionError 발생하여 테스트 통과(.) 하였고, test_zero_division_2 함수는 Divide Zero ExceptionError 발생하지 않았고 테스트 통과 실패(F) 하였다.&lt;/p&gt;

&lt;p&gt;다음은 참고한 문서이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/assert.html#assertions-about-expected-exceptions&quot;&gt;https://docs.pytest.org/en/latest/assert.html#assertions-about-expected-exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;pytest의-fixture-설명&quot;&gt;Pytest의 Fixture 설명&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;Pytest framework에서는 입력 인자를 Fixture로 명명하여 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;Fixture를 사용하면 테스트 코드가 간결해지고, 재활용할 수 있어 효율적인 테스트를 할 수 있다.&lt;/p&gt;

&lt;p&gt;Fixture는 데코레이터(@pytest.fixture)를 활용하여 사용한다. 해당 부분은 &lt;a href=&quot;https://docs.pytest.org/en/latest/fixture.html#fixtures-as-function-arguments&quot;&gt;Pytest 공식사이트 Fixture 문서&lt;/a&gt;를 참고해 기술했다.&lt;/p&gt;

&lt;h2 id=&quot;fixture를-이용해-함수를-변수처럼-사용하기&quot;&gt;Fixture를 이용해 함수를 변수처럼 사용하기&lt;/h2&gt;

&lt;p&gt;test_square_10.py를 생성하고 다음과 같이 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pytest

@pytest.fixture
def square_10():
    return 10 * 10


def test_square(square_10):
    assert square_10 == 100
    assert square_10 == 121
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fixture로 명명한 square_10은 변수처럼 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;PyTest framework로 test_square_10.py를 실행하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_square_10.py
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /Users/kevin/dev/pytest_tutorial/fixture
collected 1 item                                                                                                                                                                                                                            

test_square_10.py F                                                                                                                                                                                                               [100%]

================================================================================================================= FAILURES ==================================================================================================================
________________________________________________________________________________________________________________ test_square ________________________________________________________________________________________________________________

square_10 = 100

    def test_square(square_10):
        assert square_10 == 100
&amp;gt;       assert square_10 == 121
E       assert 100 == 121
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과를 확인하면 &lt;em&gt;assert square_10 == 121&lt;/em&gt; 에서 테스트 통과 실패했다.&lt;/p&gt;

&lt;p&gt;square_10 함수를 실행하고 반환되는 값 100을 변수처럼 사용할 수 있다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;fixture는 conftest.py에 정의하여 다수의 테스트 코드에서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;다수의 테스트 코드에서 fixture를 사용해보자.&lt;/p&gt;

&lt;p&gt;conftest.py를 생성하고 다음과 같이 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pytest

@pytest.fixture
def square_10():
    return 10 * 10

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;test_fixture_over.py, test_fixture_under.py를 생성하고 아래와 같이 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def test_square_10_over(square_10):
    assert square_10 == 100
    assert square_10 == 121


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def test_square_10_under(square_10):
    assert square_10 == 100
    assert square_10 == 81

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;test_square_10_over, test_square_10_under 함수는 sqaure_10를 인자로 받아서 assert 문을 수행한다.&lt;/p&gt;

&lt;p&gt;PyTest framework를 실행하고 결과를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest *er.py
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /Users/kevin/dev/pytest_tutorial/fixture/over_under
collected 2 items                                                                                                                                                                                                                           

test_fixture_over.py F                                                                                                                                                                                                                [ 50%]
test_fixture_under.py F                                                                                                                                                                                                               [100%]

================================================================================================================= FAILURES ==================================================================================================================
____________________________________________________________________________________________________________ test_square_10_over ____________________________________________________________________________________________________________

square_10 = 100

    def test_square_10_over(square_10):
        assert square_10 == 100
&amp;gt;       assert square_10 == 121
E       assert 100 == 121

test_fixture_over.py:3: AssertionError
___________________________________________________________________________________________________________ test_square_10_under ____________________________________________________________________________________________________________

square_10 = 100

    def test_square_10_under(square_10):
        assert square_10 == 100
&amp;gt;       assert square_10 == 81
E       assert 100 == 81

test_fixture_under.py:3: AssertionError
============================================================================================================= 2 failed in 0.04s =============================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;conftest.py에서 정의한 fixture square_10는 test_square_10_over 함수와 test_square_10_under 함수의 인자로 전달되었다.&lt;/p&gt;

&lt;h2 id=&quot;pytest-fixture를-활용해-테스트코드-setup-teardown-만들기&quot;&gt;Pytest fixture를 활용해 테스트코드 Setup, teardown 만들기&lt;/h2&gt;

&lt;p&gt;Pytest의 fixture는 다음과 같은 경우 주로 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테스트를 위한 데이터 셋업과 데이터 클리닝이 반복적, 독립적으로 사용 될 때&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fixture의 실제 사용 예는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;테스트를 위한 특정 파일과 디렉토리를 만들고 테스트 종료 시 해당 파일과 디렉토리를 삭제한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DB를 연결하고 테스트 종료 시 DB 연결을 정상적으로 종료한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;학습을 위해 다음과 같은 사용사례를 가정해 진행한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;테스트를 위한 임시 디렉토리와 파일을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;임시 파일에 데이터를 입력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터를 입력 완료 후 임시 디렉토리와 파일을 삭제한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테스트를 종료한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 사례를 직접 경험하기 위해 다음과 같이 코드를 입력한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pytest
import os
import smtplib


# yield을 활용한 Teardown
@pytest.fixture
def make_directory_and_txt_file_yield():
    directory_name = &quot;/data/&quot;
    directory_path = os.getcwd()+directory_name
    try:
        if not(os.path.isdir(directory_path)):
            os.makedirs(os.path.join(directory_path))
            print(&quot;\nmake directory&quot;, directory_path)
    except Exception as e:
        print(&quot;make_directory() has error \n error message: {}&quot;.format(e))    
    
    file_name = &quot;temp_data.txt&quot;
    print(&quot;make file&quot;, file_name)
    f = open(directory_path+file_name, 'w')
    yield f

    f.close()
    os.remove(directory_path+file_name)
    print(&quot;\ndelete temp file &quot;, directory_path+file_name)
    os.rmdir(directory_path)
    print(&quot;delete directory &quot;, directory_path)
    print(&quot;teardown complete&quot;)


def test_file_write_yield(make_directory_and_txt_file_yield):
    file_pointer = make_directory_and_txt_file_yield
    file_pointer.write(&quot;data write&quot;)
    print(&quot;data write to file&quot;)


# request.addfinalizer을 활용한 Teardown
@pytest.fixture
def make_directory_and_txt_file_addfinalizer(request):
    directory_name = &quot;/data/&quot;
    directory_path = os.getcwd()+directory_name
    try:
        if not(os.path.isdir(directory_path)):
            os.makedirs(os.path.join(directory_path))
            print(&quot;\nmake directory&quot;, directory_path)
    except Exception as e:
        print(&quot;make_directory() has error \n error message: {}&quot;.format(e))    
    
    file_name = &quot;temp_data.txt&quot;
    print(&quot;make file&quot;, file_name)
    f = open(directory_path+file_name, 'w')

    def teardown():
        f.close()
        os.remove(directory_path+file_name)
        print(&quot;\ndelete temp file &quot;, directory_path+file_name)
        os.rmdir(directory_path)
        print(&quot;delete directory &quot;, directory_path)
        print(&quot;teardown complete&quot;)

    request.addfinalizer(teardown)

    return f

    
def test_file_write_addfinalizer(make_directory_and_txt_file_addfinalizer):
    file_pointer = make_directory_and_txt_file_addfinalizer
    file_pointer.write(&quot;data write&quot;)
    print(&quot;data write to file&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 명령어를 입력한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest pytest -v -s test_fixture.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;================================================================================================================================================ test session starts ==============================================================================================================================
platform darwin -- Python 3.7.3, pytest-5.2.2, py-1.8.0, pluggy-0.13.0 -- /Users/st/test/pytest/.venv/bin/python3.7
cachedir: .pytest_cache
rootdir: /Users/st/test/pytest
collected 2 items                                                                                                                                                                                                                                                                                                    

tests/test_module.py::test_file_write_yield 
make directory /Users/st/test/pytest/data/
make file temp_data.txt
data write to file
PASSED
delete temp file  /Users/st/test/pytest/data/temp_data.txt
delete directory  /Users/st/test/pytest/data/
teardown complete

tests/test_module.py::test_file_write_addfinalizer 
make directory /Users/st/test/pytest/data/
make file temp_data.txt
data write to file
PASSED
delete temp file  /Users/st/test/pytest/data/temp_data.txt
delete directory  /Users/st/test/pytest/data/
teardown complete


================================================================================================================================================= 2 passed in 0.20s ===============================================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 결과를 통해 정상적으로 테스트를 위한 디렉토리, 파일 생성과 테스트 완료 후 해당 디렉토리와 파일을 정상적으로 삭제가 되었다는 것을 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;pytest-fixture의-파라미터-인자-설정으로-다수의-fixture-생성하기&quot;&gt;Pytest fixture의 파라미터 인자 설정으로 다수의 fixture 생성하기&lt;/h2&gt;

&lt;p&gt;Pytest fixture의 params 인수를 활용하면 다수의 fixture 값을 생성하여 테스트 할 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 다수의 fixture 값을 생성하는 테스트 코드이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pytest


@pytest.fixture(params=[1, 2, 3])
def make_double_value(request):
    return (request.param, request.param * 2)


def test_double_value(make_double_value):
    assert make_double_value[1] == (make_double_value[0] * 2 + 1)ㅗ1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;make_double_value 함수로 생성되는 fixture에 대하여 설명하면 requst.param = 1, request.param = 2, request.param = 3인 케이스 별로 fixture를 생성한다.&lt;/p&gt;

&lt;p&gt;pytest framework로 test_params.py를 실행하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_params.py
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /Users/kevin/dev/pytest_tutorial/fixture
collected 3 items                                                                                                                                                                                                                           

test_params.py FFF                                                                                                                                                                                                           [100%]

================================================================================================================= FAILURES ==================================================================================================================
___________________________________________________________________________________________________________ test_double_value[1] ____________________________________________________________________________________________________________

make_double_value = (1, 2)

    def test_double_value(make_double_value):
&amp;gt;       assert make_double_value[1] == (make_double_value[0] * 2 + 1)
E       assert 2 == ((1 * 2) + 1)

test_params.py:10: AssertionError
___________________________________________________________________________________________________________ test_double_value[2] ____________________________________________________________________________________________________________

make_double_value = (2, 4)

    def test_double_value(make_double_value):
&amp;gt;       assert make_double_value[1] == (make_double_value[0] * 2 + 1)
E       assert 4 == ((2 * 2) + 1)

test_params.py:10: AssertionError
___________________________________________________________________________________________________________ test_double_value[3] ____________________________________________________________________________________________________________

make_double_value = (3, 6)

    def test_double_value(make_double_value):
&amp;gt;       assert make_double_value[1] == (make_double_value[0] * 2 + 1)
E       assert 6 == ((3 * 2) + 1)

test_params.py:10: AssertionError
============================================================================================================= 3 failed in 0.04s =============================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인자 [ 1, 2, 3]에 맞추어 make_double_value fixture가 [(1, 2), (2, 4), (3, 6)] 생성된 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 참고한 문서이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/parametrize.html#pytest-mark-parametrize-parametrizing-test-functions&quot;&gt;https://docs.pytest.org/en/latest/parametrize.html#pytest-mark-parametrize-parametrizing-test-functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;파라미터-인자를-직접-테스트-코드에-전달하기&quot;&gt;파라미터 인자를 직접 테스트 코드에 전달하기&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;@pytest.mark.parametrize 데코레이터를 사용하면 테스트 코드에 파라미터 인자를 전달할 수 있다.&lt;/p&gt;

&lt;p&gt;리스트로 다수의 파라미터 인자를 전달하여 다수 케이스에 대한 테스트를 할 수도 있다.&lt;/p&gt;

&lt;p&gt;@pytest.mark.parametrize 정의한 파라미터 명을 정확하게 적어야 하며, 순서는 관계가 없다.&lt;/p&gt;

&lt;p&gt;아래의 test_expectation.py는 연산을 입력받아 연산하고 기대값과 비교하는 테스트 코드이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pytest


@pytest.mark.parametrize(&quot;test_input,expected&quot;, [(&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42)])
def test_eval(test_input, expected):
    assert eval(test_input) == expected
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 총 3가지 케이스가 발생하여 테스트 코드가 실행될 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;test_input = “3+5”, expected = 8&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test_input = “2+4”, expected = 6&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test_input = “6*9”, expected = 42 &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pytest framework를 실행하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pytest test_expectation.py
============================================================================================================ test session starts ============================================================================================================
platform darwin -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /Users/kevin/dev/pytest_tutorial/fixture
collected 3 items                                                                                                                                                                                                                           

test_expectation.py ..F                                                                                                                                                                                                           [100%]

================================================================================================================= FAILURES ==================================================================================================================
_____________________________________________________________________________________________________________ test_eval[6*9-42] _____________________________________________________________________________________________________________

test_input = '6*9', expected = 42

    @pytest.mark.parametrize(&quot;test_input,expected&quot;, [(&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42)])
    def test_eval(test_input, expected):
&amp;gt;       assert eval(test_input) == expected
E       AssertionError: assert 54 == 42
E        +  where 54 = eval('6*9')

test_expectation.py:7: AssertionError
======================================================================================================== 1 failed, 2 passed in 0.08s ========================================================================================================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3가지 케이스가 실행되었다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;해당 기능에 대해 이해를 돕기 위해 실제 사용 레퍼런스를 발췌해 남긴다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# content of test_time.py

import pytest

from datetime import datetime, timedelta

testdata = [
    (datetime(2001, 12, 12), datetime(2001, 12, 11), timedelta(1)),
    (datetime(2001, 12, 11), datetime(2001, 12, 12), timedelta(-1)),
]


@pytest.mark.parametrize(&quot;a,b,expected&quot;, testdata)
def test_timedistance_v0(a, b, expected):
    diff = a - b
    assert diff == expected


@pytest.mark.parametrize(&quot;a,b,expected&quot;, testdata, ids=[&quot;forward&quot;, &quot;backward&quot;])
def test_timedistance_v1(a, b, expected):
    diff = a - b
    assert diff == expected


def idfn(val):
    if isinstance(val, (datetime,)):
        # note this wouldn't show any hours/minutes/seconds
        return val.strftime(&quot;%Y%m%d&quot;)


@pytest.mark.parametrize(&quot;a,b,expected&quot;, testdata, ids=idfn)
def test_timedistance_v2(a, b, expected):
    diff = a - b
    assert diff == expected


@pytest.mark.parametrize(
    &quot;a,b,expected&quot;,
    [
        pytest.param(
            datetime(2001, 12, 12), datetime(2001, 12, 11), timedelta(1), id=&quot;forward&quot;
        ),
        pytest.param(
            datetime(2001, 12, 11), datetime(2001, 12, 12), timedelta(-1), id=&quot;backward&quot;
        ),
    ],
)
def test_timedistance_v3(a, b, expected):
    diff = a - b
    assert diff == expected
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 참고한 문서이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/latest/parametrize.html#pytest-mark-parametrize-parametrizing-test-functions&quot;&gt;https://docs.pytest.org/en/latest/parametrize.html#pytest-mark-parametrize-parametrizing-test-functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Pytest" /><category term="Python" /><category term="Test" /><summary type="html">이 문서는 Pytest framework에 관하여 학습한 내용을 정리하기 위해 작성되었다.</summary></entry><entry><title type="html">Docker 컨테이너간 볼륨 공유에 대한 학습</title><link href="http://localhost:4000/docker/docker_volume_mount/" rel="alternate" type="text/html" title="Docker 컨테이너간 볼륨 공유에 대한 학습" /><published>2019-12-19T00:00:00+09:00</published><updated>2019-12-19T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker_volume_mount</id><content type="html" xml:base="http://localhost:4000/docker/docker_volume_mount/">&lt;h1 id=&quot;문서-목적&quot;&gt;문서 목적&lt;/h1&gt;

&lt;p&gt;다수의 Docker 컨테이너(이하 컨테이너)를 운영하다가 보면 컨테이너 간에 볼륨 공유가 필요할 상황이 있다.&lt;/p&gt;

&lt;p&gt;예를 들면 Apache 서버 컨테이너의 로그 파일을 Fluentd 컨테이너로 수집하는 경우이다.&lt;/p&gt;

&lt;p&gt;이 경우 Fluentd가 Apache 서버의 로그 파일을 접근하려면 다음과 같이 두 가지 방법이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Fluentd가 Apache 서버 컨테이너 볼륨에 접근하여 로그 파일을 수집하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호스트 OS에 공유 볼륨을 생성한 후 이 공간에 Apache 서버는 로그 파일을 저장하고 Fluentd는 로그 파일을 수집하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/dtevangelist/docker-%EA%B8%B0%EB%B3%B8-5-8-volume%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-data-%EA%B4%80%EB%A6%AC-9a9ac1db978c&quot;&gt;Volume을 활용한 Data 관리&lt;/a&gt;를 살펴보면 후자의 방법이 합리적이라고 설명하고 있다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 컨테이너간 볼륨 공유를 위하여 호스트 OS에 공유 볼륨을 생성하는 방법과 실제로 테스트하여 동작 확인 한다.&lt;/p&gt;

&lt;h1 id=&quot;docker로-호스트-os에-볼륨을-공유하는-방법&quot;&gt;Docker로 호스트 OS에 볼륨을 공유하는 방법&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/storage/&quot;&gt;Docker 공식 문서 - 저장 공간&lt;/a&gt;을 살펴보면 mount 하는 방법에 따라 다음과 같이 구분한다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Bind mount&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Volume&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tmpfs&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문서에서는 휘발성 메모리에 mount 하는 tmpfs에 대하여는 다루지 않는다.&lt;/p&gt;

&lt;h1 id=&quot;테스트-환경&quot;&gt;테스트 환경&lt;/h1&gt;

&lt;p&gt;다음과 같은 환경에서 테스트 하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;OS &lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;버전 : masOS Mojave v10.14.6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;버전 : 19.03.2&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Python 이미지 - 버전 : 3.6&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Fluentd 이미지 - 버전 : v1.0.2 &lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;사용되는-docker-cli-명령어&quot;&gt;사용되는 Docker CLI 명령어&lt;/h1&gt;

&lt;p&gt;이 문서에서는 다음과 같은 Docker 명령어를 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker build&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker container&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker image&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker stop&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker rm&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker volume&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 나열된 명령어의 설명과 사용법은 다음의 링크를 참고하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/build/&quot;&gt;Docker 공식문서 - docker build&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/container/&quot;&gt;Docker 공식문서 - docker container&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/image/&quot;&gt;Docker 공식문서 - docker image&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/run/&quot;&gt;Docker 공식문서 - docker run&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/stop/&quot;&gt;Docker 공식문서 - docker stop&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/stop/&quot;&gt;Docker 공식문서 - docker rm&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/stop/&quot;&gt;Docker 공식문서 - docker volume&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mount와 관련하여 다음과 같은 주의사항이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;-v 옵션: Host OS에서 해당 경로의 디렉터리가 존재하지 않으면 새롭게 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-mount 옵션 : Host OS에서 해당 경로의 디렉터리가 존재하지 않으면 mount 자체가 안 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;테스트-사전-정보&quot;&gt;테스트 사전 정보&lt;/h1&gt;

&lt;h2 id=&quot;환경-변수-등록&quot;&gt;환경 변수 등록&lt;/h2&gt;

&lt;p&gt;테스트 편의를 위하여 다음과 같이 환경 변수를 등록하여 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export DOCKER_SHARED_VOLUME_TEST_PATH=/Users/kevin/dev/docker/test/shared_volume

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ env
... 중략 ...

DOCKER_SHARED_VOLUME_TEST_PATH=/Users/kevin/dev/docker/test/shared_volume

... 중략 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;로그생성-컨테이너-이미지-생성&quot;&gt;“로그생성” 컨테이너 이미지 생성&lt;/h2&gt;

&lt;p&gt;이 테스트에서는 “로그생성” 컨테이너의 이미지 생성은 다음과 같이 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;다음과 같이 Dockerfile을 생성한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat image_of_make_logfile/Dockerfile
FROM python:3.6
RUN mkdir -p /app
RUN mkdir -p /app/input
WORKDIR /app
COPY . /app
ENV NAME Make_Log_File
CMD [&quot;python&quot;, &quot;make_log.py&quot;, &quot;5&quot;, &quot;60&quot;, &quot;/app/input/&quot;]
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음과 같은 Python 코드를 작성한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### image_of_make_logfile/make_log.py
    
import random
import sys
import datetime
import time
    
    
def main():
    sys_argv = sys.argv
    batch_count = 5
    make_log_running_time = 60
    log_file_dir_path = &quot;./&quot;
    
    if len(sys_argv) &amp;gt; 3:
        batch_count = int(sys_argv[1])
        make_log_running_time = int(sys_argv[2])
        log_file_dir_path = sys_argv[3]
    
    choice_list = [&quot;c++&quot;, &quot;python&quot;, &quot;java&quot;,
                   &quot;javascript&quot;, &quot;kotlin&quot;, &quot;scala&quot;, &quot;ruby&quot;]
    
    now_date = datetime.datetime.today()
    filename = &quot;&quot;.join([log_file_dir_path, str(now_date.date()), &quot;.log&quot;])
    
    for batch_no in range(batch_count):
        with open(filename, &quot;a&quot;) as file_object:
            for i in range(make_log_running_time):
                time.sleep(0.999999)
                created_at = time.strftime(&quot;%Y/%m/%dT%H:%M:%S&quot;)
                log_message = &quot;{}-{}    {}    {}\n&quot;.format(
                    batch_no, i, created_at, random.choice(choice_list))
                file_object.write(log_message)
    print(&quot;make log end!&quot;)
    
    
if __name__ == &quot;__main__&quot;:
    main()
    
    
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음과 같이 Docker 이미지를 생성한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd image_of_make_logfile
$ docker build --tag=make_logfile_image .
Sending build context to Docker daemon  11.26kB
Step 1/7 : FROM python:3.6
 ---&amp;gt; 1c515a624542
Step 2/7 : RUN mkdir -p /app
 ---&amp;gt; Running in a993e327f25c
Removing intermediate container a993e327f25c
 ---&amp;gt; b4b52d6451f8
Step 3/7 : RUN mkdir -p /app/input
 ---&amp;gt; Running in a944e3182d51
Removing intermediate container a944e3182d51
 ---&amp;gt; 20d3277a9ee7
Step 4/7 : WORKDIR /app
 ---&amp;gt; Running in 09577255b80a
Removing intermediate container 09577255b80a
 ---&amp;gt; 2d6f8cbc1cde
Step 5/7 : COPY . /app
 ---&amp;gt; dcbd7f937bad
Step 6/7 : ENV NAME Make_Log_File
 ---&amp;gt; Running in b41268eb0611
Removing intermediate container b41268eb0611
 ---&amp;gt; 1c2d3febff85
Step 7/7 : CMD [&quot;python&quot;, &quot;make_log.py&quot;, &quot;5&quot;, &quot;60&quot;, &quot;/app/input/&quot;]
 ---&amp;gt; Running in 630ce115c0e4
Removing intermediate container 630ce115c0e4
 ---&amp;gt; 5a345b58606c
Successfully built 5a345b58606c
Successfully tagged make_logfile_image:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;로그수집-컨테이너-설정파일&quot;&gt;“로그수집” 컨테이너 설정파일&lt;/h2&gt;

&lt;p&gt;Fluentd 이미지를 사용할 예정이며 td-agent 설정 파일은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat fluentd/td_agent.conf
&amp;lt;source&amp;gt;
  @type tail
  tag docker_log_collect
  path /input/*
  &amp;lt;parse&amp;gt;
    @type none
  &amp;lt;/parse&amp;gt;
  refresh_interval 5s
  read_from_head true
&amp;lt;/source&amp;gt;

&amp;lt;match docker_log_collect*&amp;gt;
  @type file
  path /output/${tag}_output
  add_path_suffix true
  path_suffix &quot;.log&quot;
  append true
  &amp;lt;buffer tag&amp;gt;
    flush_mode interval
    flush_interval 3s
  &amp;lt;/buffer&amp;gt;
  &amp;lt;format&amp;gt;
    @type out_file
    output_tag false
    output_time true
  &amp;lt;/format&amp;gt;
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;bind-mount&quot;&gt;Bind mount&lt;/h1&gt;

&lt;p&gt;Bind mount는 Host OS에 종속적이다.&lt;/p&gt;

&lt;p&gt;컨테이너를 실행하면 –mount 혹은 -v 옵션에서 Host OS 로컬 경로와 컨테이너 경로를 mount만 하면 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 컨테이너와 Bind mount된 Storage에 파일이 저장된다면 Host OS에서도 확인할 수도 있다.&lt;/p&gt;

&lt;p&gt;더 자세한 내용은 다음의 링크를 참고하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/storage/bind-mounts/&quot;&gt;Docker 공식 문서 - 저장 공간 / Bind mounts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테스트&quot;&gt;테스트&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 할 예정이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;“로그생성” 컨테이너를 구성하고 실행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“로그수집” 컨테이너를 구성하고 실행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Host OS 상에서 입력용 로그 파일과 출력용 로그 파일을 비교한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-로그-생성-컨테이너-실행&quot;&gt;1. 로그 생성 컨테이너 실행&lt;/h3&gt;

&lt;p&gt;테스트 사전 정보에서 생성한 Docker 이미지를 바탕으로 컨테이너를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name=make_logfile_container --mount type=bind,source=${DOCKER_SHARED_VOLUME_TEST_PATH}/host_storage/input,target=/app/input make_logfile_image:latest
bd31f0fb4e4a03eb16375e5ff6fcd1e95998dec26802cb457f56f5ff31572b46
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너의 상태를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker container ps --all
CONTAINER ID        IMAGE                       COMMAND                  CREATED              STATUS              PORTS               NAMES
bd31f0fb4e4a        make_logfile_image:latest   &quot;python make_log.py …&quot;   About a minute ago   Up About a minute                       make_logfile_container

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너의 Mount상태를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker inspect make_logfile_container
[
    ... 중략 ...
    &quot;Mounts&quot;: [
            {
                &quot;Type&quot;: &quot;bind&quot;,
                &quot;Source&quot;: &quot;/Users/kevin/dev/docker/test/shared_volume/host_storage/input&quot;,
                &quot;Destination&quot;: &quot;/app/input&quot;,
                &quot;Mode&quot;: &quot;&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;rprivate&quot;
            }
        ],
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;입력용 로그 파일에 로그가 저장되는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/input/2019-09-10.log
0-0    2019/09/10T05:49:19    scala
0-1    2019/09/10T05:49:20    ruby
0-2    2019/09/10T05:49:21    c++
0-3    2019/09/10T05:49:22    c++
0-4    2019/09/10T05:49:23    c++

... 중략 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;초당 1개 로그를  5분간 파일에 저장한다.&lt;/p&gt;

&lt;h3 id=&quot;2-로그-수집-컨테이너-실행&quot;&gt;2. 로그 수집 컨테이너 실행&lt;/h3&gt;

&lt;p&gt;테스트 사전 정보의 td-agent 설정 파일을 바탕으로 Fluentd 컨테이너를 다음과 같이 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name=log_collector_container --mount type=bind,source=${DOCKER_SHARED_VOLUME_TEST_PATH}/host_storage/input,target=/input --mount type=bind,source=${DOCKER_SHARED_VOLUME_TEST_PATH}/host_storage/output,target=/output --mount type=bind,source=${DOCKER_SHARED_VOLUME_TEST_PATH}/fluentd,target=/fluentd/etc -e FLUENTD_CONF=td_agent.conf fluent/fluentd:v1.0.2
47a6f572fdb2427a0872266ce373b9e99da1e2cae5ee4dc83f0d5aaaf6f56cd2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너가 실행되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker container ps --all
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                      PORTS                 NAMES
47a6f572fdb2        fluent/fluentd:v1.0.2       &quot;/bin/entrypoint.sh …&quot;   5 minutes ago       Up 5 minutes                5140/tcp, 24224/tcp   log_collector_container
bd31f0fb4e4a        make_logfile_image:latest   &quot;python make_log.py …&quot;   22 minutes ago      Exited (0) 17 minutes ago                         make_logfile_container
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너의 Mount상태를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker inspect log_collector_container
[
    ... 중략 ...
    &quot;Mounts&quot;: [
            {
                &quot;Type&quot;: &quot;bind&quot;,
                &quot;Source&quot;: &quot;/Users/kevin/dev/docker/test/shared_volume/host_storage/input&quot;,
                &quot;Destination&quot;: &quot;/input&quot;,
                &quot;Mode&quot;: &quot;&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;rprivate&quot;
            },
{
                &quot;Type&quot;: &quot;bind&quot;,
                &quot;Source&quot;: &quot;/Users/kevin/dev/docker/test/shared_volume/host_storage/output&quot;,
                &quot;Destination&quot;: &quot;/output&quot;,
                &quot;Mode&quot;: &quot;&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;rprivate&quot;
            },
            {
                &quot;Type&quot;: &quot;bind&quot;,
                &quot;Source&quot;: &quot;/Users/kevin/dev/docker/test/shared_volume/fluentd&quot;,
                &quot;Destination&quot;: &quot;/fluentd/etc&quot;,
                &quot;Mode&quot;: &quot;&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;rprivate&quot;
            }
        ],
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;출력용 로그파일에 저장되는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/output/docker_log_collect_output.log
019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-0    2019/09/10T05:49:19    scala&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-1    2019/09/10T05:49:20    ruby&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-2    2019/09/10T05:49:21    c++&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-3    2019/09/10T05:49:22    c++&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-4    2019/09/10T05:49:23    c++&quot;}

... 중략 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-입출력용-로그-파일-확인&quot;&gt;3. 입,출력용 로그 파일 확인&lt;/h3&gt;

&lt;p&gt;입력용 로그 파일을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/input/2019-09-10.log
0-0    2019/09/10T05:49:19    scala
0-1    2019/09/10T05:49:20    ruby
0-2    2019/09/10T05:49:21    c++
0-3    2019/09/10T05:49:22    c++
0-4    2019/09/10T05:49:23    c++

... 중략 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/input/2019-09-10.log| wc -l
300
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;출력용 로그 파일을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/output/docker_log_collect_output.log
019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-0    2019/09/10T05:49:19    scala&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-1    2019/09/10T05:49:20    ruby&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-2    2019/09/10T05:49:21    c++&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-3    2019/09/10T05:49:22    c++&quot;}
2019-09-10T06:06:39+00:00	{&quot;message&quot;:&quot;0-4    2019/09/10T05:49:23    c++&quot;}

... 중략 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/output/docker_log_collect_output.log| wc -l
300
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;입력용 로그 파일과 출력용 로그 파일을 비교한 결과는 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;p&gt;입력용 로그 파일의 내용은 출력용 로그 파일에 ‘수집날짜 { “message” : “로그 내용” } 형태로 저장된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;volume&quot;&gt;Volume&lt;/h1&gt;

&lt;p&gt;Volume 마운트는 Host OS에 파일 시스템에 종속적이지 않으며 Docker에서 완전히 관리 한다. &lt;/p&gt;

&lt;p&gt;volume 마운트를 사용하기 위해서는 Docker 명령으로 volume 생성이 필요하다.&lt;/p&gt;

&lt;p&gt;더 자세한 내용은 다음의 링크를 참고하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Docker 공식 문서 - 저장 공간 / Volume&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테스트-1&quot;&gt;테스트&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 할 예정이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Volume을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“로그생성” 컨테이너를 구성하고 실행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“로그수집” 컨테이너를 구성하고 실행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Host OS 상에서 입력용 로그 파일과 출력용 로그 파일을 비교한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-volume-생성&quot;&gt;1. Volume 생성&lt;/h3&gt;

&lt;p&gt;다음과 같이 Volume을 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker volume create logfile_input
logfile_input
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 명령으로 Volume의 상태를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker volume inspect logfile_input
[
    {
        &quot;CreatedAt&quot;: &quot;2019-09-10T08:41:41Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/logfile_input/_data&quot;,
        &quot;Name&quot;: &quot;logfile_input&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-로그-생성-컨테이너-실행&quot;&gt;2. 로그 생성 컨테이너 실행&lt;/h3&gt;

&lt;p&gt;테스트 사전 정보에서 생성한 Docker 이미지를 바탕으로 컨테이너를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name=make_logfile_container --mount type=volume,source=logfile_input,target=/app/input make_logfile_image:latest
7a265902761be76af2957140e0966b99d297e0fda78f5dffe17df9daca4c7453
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너의 동작을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker container ps --all
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS               NAMES
1dcc4e6c3181        make_logfile_image:latest   &quot;python make_log.py …&quot;   2 minutes ago       Up 2 minutes                            make_logfile_container

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너의 Mount상태를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker inspect make_logfile_container
[
    ... 중략 ...
    &quot;Mounts&quot;: [
            {
                &quot;Type&quot;: &quot;volume&quot;,
                &quot;Name&quot;: &quot;logfile_input&quot;,
                &quot;Source&quot;: &quot;/var/lib/docker/volumes/logfile_input/_data&quot;,
                &quot;Destination&quot;: &quot;/app/input&quot;,
                &quot;Driver&quot;: &quot;local&quot;,
                &quot;Mode&quot;: &quot;z&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;&quot;
            }
        ],
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-로그-수집-컨테이너-실행&quot;&gt;3. 로그 수집 컨테이너 실행&lt;/h3&gt;

&lt;p&gt;테스트 사전 정보의 td-agent 설정 파일을 바탕으로 Fluentd 컨테이너를 다음과 같이 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name=log_collector_container --mount type=volume,source=logfile_input,target=/input --mount type=bind,source=${DOCKER_SHARED_VOLUME_TEST_PATH}/host_storage/output,target=/output -v ${DOCKER_SHARED_VOLUME_TEST_PATH}/fluentd:/fluentd/etc -e FLUENTD_CONF=td_agent.conf fluent/fluentd:v1.0.2
ba7be8af4dc7ddea4ba30ebccb80736f9700717289748b74e27ab45e9ab22195
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너가 실행되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker container ps --all
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                 NAMES
ba7be8af4dc7        fluent/fluentd:v1.0.2       &quot;/bin/entrypoint.sh …&quot;   5 seconds ago       Up 4 seconds        5140/tcp, 24224/tcp   log_collector_container
1dcc4e6c3181        make_logfile_image:latest   &quot;python make_log.py …&quot;   4 minutes ago       Up 4 minutes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-출력용-로그-파일-확인&quot;&gt;3. 출력용 로그 파일 확인&lt;/h3&gt;

&lt;p&gt;출력용 로그 파일을 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/output/docker_log_collect_output.log
2019-09-16T00:41:33+00:00	{&quot;message&quot;:&quot;0-0    2019/09/10T09:39:39    kotlin&quot;}
2019-09-16T00:41:33+00:00	{&quot;message&quot;:&quot;0-1    2019/09/10T09:39:40    ruby&quot;}
2019-09-16T00:41:33+00:00	{&quot;message&quot;:&quot;0-2    2019/09/10T09:39:41    c++&quot;}
2019-09-16T00:41:33+00:00	{&quot;message&quot;:&quot;0-3    2019/09/10T09:39:42    kotlin&quot;}
2019-09-16T00:41:33+00:00	{&quot;message&quot;:&quot;0-4    2019/09/10T09:39:43    scala&quot;}

... 중략 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat host_storage/output/docker_log_collect_output.log| wc -l
300
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;출력용 로그 파일을 확인한 결과 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;p&gt;입력용 로그 파일의 내용이 출력용 로그 파일에 ‘수집날짜 { “message” : “로그 내용” } 형태로 저장된다.&lt;/p&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Docker" /><summary type="html">다수의 Docker 컨테이너(이하 컨테이너)를 운영하다가 보면 컨테이너 간에 볼륨 공유가 필요할 상황이 있다.</summary></entry><entry><title type="html">Docker 공식 사이트 Chapter 1~3 학습 내용 정리</title><link href="http://localhost:4000/docker/docker_basic/" rel="alternate" type="text/html" title="Docker 공식 사이트 Chapter 1~3 학습 내용 정리" /><published>2019-12-17T00:00:00+09:00</published><updated>2019-12-17T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker_basic</id><content type="html" xml:base="http://localhost:4000/docker/docker_basic/">&lt;h1 id=&quot;목적&quot;&gt;목적&lt;/h1&gt;

&lt;p&gt;이 문서는 2019. 9. 2 기준 &lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Docker 시작하기&lt;/a&gt;를 따라하며 개인적인 학습과 추후 이 내용을 리마인드 할 때 참고하려는 목적을 가지고 있다.&lt;/p&gt;

&lt;h1 id=&quot;진행&quot;&gt;진행&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Docker 시작하기&lt;/a&gt;는 6개의 part로 나뉘어져 있으며 다음과 같다. 이 중 part 3까지만 진행한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;오리엔테이션&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스웜&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;앱 배포&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스웜의 경우 쿠버네티스를 사용하는 트렌드 비춰 학습에서 제외한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스택, 6. 앱 배포의 경우 스웜이 초기화 되야만 동작하기 때문에 학습에서 제외한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-오리엔테이션&quot;&gt;1. 오리엔테이션&lt;/h2&gt;

&lt;p&gt;개념적인 내용은 &lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Docker 시작하기&lt;/a&gt;를 참고하고 docker 실행과 관련된 내용만 남긴다.&lt;/p&gt;

&lt;p&gt;Docker의 버전 확인&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker 설치에 대한 자세한 정보 확인&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker version

### 혹은

$ docker info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hello world 실행&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker container ls --all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-컨테이너&quot;&gt;2. 컨테이너&lt;/h2&gt;

&lt;h3 id=&quot;docker-이미지-생성-컨테이너-실행-튜토리얼-진행&quot;&gt;Docker 이미지 생성, 컨테이너 실행 튜토리얼 진행&lt;/h3&gt;

&lt;p&gt;컨테이너로 단순한 서버를 구축하는 튜토리얼을 진행한다.&lt;/p&gt;

&lt;p&gt;우선 Dockerfile을 만든다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch Dockerfile

$ cat Dockerfile
# Use an official Python runtime as a parent image
FROM python:2.7-slim

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD [&quot;python&quot;, &quot;app.py&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python 패키지 목록을 만든다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat requirements.txt
Flask
Redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;소스코드 작성 app.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat app.py
from flask import Flask
from redis import Redis, RedisError
import os
import socket

# Connect to Redis
redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)

app = Flask(__name__)

@app.route(&quot;/&quot;)
def hello():
    try:
        visits = redis.incr(&quot;counter&quot;)
    except RedisError:
        visits = &quot;&amp;lt;i&amp;gt;cannot connect to Redis, counter disabled&amp;lt;/i&amp;gt;&quot;

    html = &quot;&amp;lt;h3&amp;gt;Hello {name}!&amp;lt;/h3&amp;gt;&quot; \
           &quot;&amp;lt;b&amp;gt;Hostname:&amp;lt;/b&amp;gt; {hostname}&amp;lt;br/&amp;gt;&quot; \
           &quot;&amp;lt;b&amp;gt;Visits:&amp;lt;/b&amp;gt; {visits}&quot;
    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)

if __name__ == &quot;__main__&quot;:
    app.run(host='0.0.0.0', port=80)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile로 이미지를 생성하기 위하여 Dockerfile, 패키지 목록, 소스코드를 확인&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls
Dockerfile       app.py           requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile로 friendlyhello라는 이름의 이미지 만들기&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build --tag=friendlyhello .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성된 이미지 확인&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker image ls
REPOSITORY            TAG                 IMAGE ID
friendlyhello         latest              326387cea398
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성된 이미지를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -p 4000:80 friendlyhello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 컨테이너 80 포트를 4000에 매핑한다.&lt;/p&gt;

&lt;p&gt;해당 url로 접속하여 컨테이너의 동작 확인 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl http://localhost:4000
&amp;lt;h3&amp;gt;Hello World!&amp;lt;/h3&amp;gt;&amp;lt;b&amp;gt;Hostname:&amp;lt;/b&amp;gt; 86e9b8deb983&amp;lt;br/&amp;gt;&amp;lt;b&amp;gt;Visits:&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;cannot connect to Redis, counter disabled&amp;lt;/i&amp;gt;%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;백그라운드에서 실행하려면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d -p 4000:80 friendlyhello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker-이미지-공유&quot;&gt;Docker 이미지 공유&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker 허브&lt;/a&gt;에 로그인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이미지를 공유하기 위해서는 다음과 같이 이미지 태그를 설정해야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### docker tag 이미지명 유저이름/레포명:태그명
$ docker tag friendlyhello username/tutorial:part1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정한 이미지를 업로드한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker push username/tutorial:part1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker 허브&lt;/a&gt;에 로그인하여 해당 repo(예 : tutorial)는 미리 만들어야 한다.&lt;/p&gt;

&lt;p&gt;이미지를 업로드하면 다음과 같이 사용할 수 있다. 해당 이미지가 로컬에 존재하지 않는다면 자동으로 다운로드하고 로컬에 이미지를 생성해준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d -p 4000:80 username/tutorial:part1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-서비스&quot;&gt;3. 서비스&lt;/h2&gt;

&lt;p&gt;서비스의 개념은 &lt;a href=&quot;https://docs.docker.com/get-started/part3/&quot;&gt;Docker 시작하기 - part3 서비스&lt;/a&gt;를 참고한다. 서비스는 하나의 이미지만 실행하고 이미지 실행 방식을 체계화한다.&lt;/p&gt;

&lt;p&gt;서비스의 개념에서 등장하는 것이 docker-compose.yml 파일이고 이는 도커의 행동방식을 정의하는 YAML 파일이다.&lt;/p&gt;

&lt;p&gt;다음과 같이 docker-compose.yml을 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat docker-compose.yml
version: &quot;3&quot;
services:
  web:
    # replace username/repo:tag with your name and image details
    image: username/tutorial:part1
    deploy:
      replicas: 5
      resources:
        limits:
          cpus: &quot;0.1&quot;
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - &quot;4000:80&quot;
    networks:
      - webnet
networks:
  webnet:

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 YAML 파일에 대한 설명은 &lt;a href=&quot;https://docs.docker.com/get-started/part3/&quot;&gt;Docker 시작하기 - part3 서비스&lt;/a&gt;를 참고한다.&lt;/p&gt;

&lt;h3 id=&quot;새로운-load-balanced-app-실행&quot;&gt;새로운 load-balanced app 실행&lt;/h3&gt;

&lt;p&gt;배포 전에 Swarm을 초기화 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 실행하는데 getstartedlab라는 이름의 스택으로 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack deploy -c docker-compose.yml getstartedlab

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker의 서비스 목록을 확인하면 getstartedlab 뒤에 web이 붙어 getstartedlab_web이라는 형태로 서비스가 존재하는 것을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                       PORTS
r8ikpt4dypup        getstartedlab_web   replicated          5/5                 username/tutorial:part1   *:4000-&amp;gt;80/tcp

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getstartedlab 스택의 서비스를 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack services getstartedlab
ID                  NAME                MODE                REPLICAS            IMAGE                       PORTS
r8ikpt4dypup        getstartedlab_web   replicated          5/5                 username/tutorial:part1   *:4000-&amp;gt;80/tcp

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 명령으로 특정 서비스내 task 목록을 확인할 수 있다.(아마도 컨테이너 단위를 의미하는 듯 싶다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker service ps getstartedlab_web
ID                  NAME                  IMAGE                       NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
dk5k5bt68eoa        getstartedlab_web.1   username/tutorial:part1   docker-desktop      Running             Running 25 minutes ago
nq0q77gcwo03        getstartedlab_web.2   username/tutorial:part1   docker-desktop      Running             Running 25 minutes ago
hsd20wrbpkjx        getstartedlab_web.3   username/tutorial:part1   docker-desktop      Running             Running 25 minutes ago
qin17db37xvs        getstartedlab_web.4   username/tutorial:part1   docker-desktop      Running             Running 25 minutes ago
s8u54k1ax8f6        getstartedlab_web.5   username/tutorial:part1   docker-desktop      Running             Running 25 minutes ago
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 명령으로 특정 스택내 task 목록을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack ps getstartedlab
ID                  NAME                  IMAGE                       NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
dk5k5bt68eoa        getstartedlab_web.1   username/tutorial:part1   docker-desktop      Running             Running 58 minutes ago
nq0q77gcwo03        getstartedlab_web.2   username/tutorial:part1   docker-desktop      Running             Running 58 minutes ago
hsd20wrbpkjx        getstartedlab_web.3   username/tutorial:part1   docker-desktop      Running             Running 58 minutes ago
qin17db37xvs        getstartedlab_web.4   username/tutorial:part1   docker-desktop      Running             Running 58 minutes ago
s8u54k1ax8f6        getstartedlab_web.5   username/tutorial:part1   docker-desktop      Running             Running 58 minutes ago

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;앱-확장&quot;&gt;앱 확장&lt;/h3&gt;

&lt;p&gt;docker-compose.yml 파일을 다음과 같이 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat docker-compose.yml
version: &quot;3&quot;
services:
  web:
    # replace username/repo:tag with your name and image details
    image: username/tutorial:part1
    deploy:
      replicas: 10
      resources:
        limits:
          cpus: &quot;0.1&quot;
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - &quot;4000:80&quot;
    networks:
      - webnet
networks:
  webnet:

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 실행하는데 기존과 같은 getstartedlab라는 이름의 스택으로 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack deploy -c docker-compose.yml getstartedlab

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서비스를 확인하면 다음과 같이 업데이트 된 것을 확인할 수 있다. 새로운 레플리카가 생성된 것을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                       PORTS
r8ikpt4dypup        getstartedlab_web   replicated          10/10               username/tutorial:part1   *:4000-&amp;gt;80/tcp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack ps getstartedlab
ID                  NAME                   IMAGE                       NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS
dk5k5bt68eoa        getstartedlab_web.1    username/tutorial:part1   docker-desktop      Running             Running 2 hours ago
nq0q77gcwo03        getstartedlab_web.2    username/tutorial:part1   docker-desktop      Running             Running 2 hours ago
hsd20wrbpkjx        getstartedlab_web.3    username/tutorial:part1   docker-desktop      Running             Running 2 hours ago
qin17db37xvs        getstartedlab_web.4    username/tutorial:part1   docker-desktop      Running             Running 2 hours ago
s8u54k1ax8f6        getstartedlab_web.5    username/tutorial:part1   docker-desktop      Running             Running 2 hours ago
sqn7aohfghfg        getstartedlab_web.6    username/tutorial:part1   docker-desktop      Running             Running 3 minutes ago
3wee43wtqo1q        getstartedlab_web.7    username/tutorial:part1   docker-desktop      Running             Running 3 minutes ago
0h6xfiw9a92s        getstartedlab_web.8    username/tutorial:part1   docker-desktop      Running             Running 3 minutes ago
metnndctvyn4        getstartedlab_web.9    username/tutorial:part1   docker-desktop      Running             Running 3 minutes ago
rn22s1618j0g        getstartedlab_web.10   username/tutorial:part1   docker-desktop      Running             Running 3 minutes ago
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스택의 종료는 다음과 같이 한다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack rm getstartedlab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;swarm의 종료는 다음과 같이 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker swarm leave --force
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;명령어-모음&quot;&gt;명령어 모음&lt;/h1&gt;

&lt;p&gt;파트별로 진행하며 사용한 명령어만 간략하게 살펴보기 위하여 정리하였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;part1 오리엔테이션&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## List Docker CLI commands
$ docker
$ docker container --help

## Display Docker version and info
$ docker --version
$ docker version
$ docker info

## Execute Docker image
$ docker run hello-world

## List Docker images
$ docker image ls

## List Docker containers (running, all, all in quiet mode)
$ docker container ls
$ docker container ls --all
$ docker container ls -aq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;part2 컨테이너&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build -t friendlyhello .  # Create image using this directory's Dockerfile
$ docker run -p 4000:80 friendlyhello  # Run &quot;friendlyhello&quot; mapping port 4000 to 80
$ docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode
$ docker container ls                                # List all running containers
$ docker container ls -a             # List all containers, even those not running
$ docker container stop &amp;lt;hash&amp;gt;           # Gracefully stop the specified container
$ docker container kill &amp;lt;hash&amp;gt;         # Force shutdown of the specified container
$ docker container rm &amp;lt;hash&amp;gt;        # Remove specified container from this machine
$ docker container rm $(docker container ls -a -q)         # Remove all containers
$ docker image ls -a                             # List all images on this machine
$ docker image rm &amp;lt;image id&amp;gt;            # Remove specified image from this machine
$ docker image rm $(docker image ls -a -q)   # Remove all images from this machine
$ docker login             # Log in this CLI session using your Docker credentials
$ docker tag &amp;lt;image&amp;gt; username/repository:tag  # Tag &amp;lt;image&amp;gt; for upload to registry
$ docker push username/repository:tag            # Upload tagged image to registry
$ docker run username/repository:tag                   # Run image from a registry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;part3 서비스&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker stack ls                                            # List stacks or apps
$ docker stack deploy -c &amp;lt;composefile&amp;gt; &amp;lt;appname&amp;gt;  # Run the specified Compose file
$ docker service ls                 # List running services associated with an app
$ docker service ps &amp;lt;service&amp;gt;                  # List tasks associated with an app
$ docker inspect &amp;lt;task or container&amp;gt;                   # Inspect task or container
$ docker container ls -q                                      # List container IDs
$ docker stack rm &amp;lt;appname&amp;gt;                             # Tear down an application
$ docker swarm leave --force      # Take down a single node swarm from the manager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Docker" /><summary type="html">이 문서는 2019. 9. 2 기준 Docker 시작하기를 따라하며 개인적인 학습과 추후 이 내용을 리마인드 할 때 참고하려는 목적을 가지고 있다.</summary></entry><entry><title type="html">Boto3를 이용한 Amazon S3, Kinesis Data Firehose 사용하기</title><link href="http://localhost:4000/boto3/boto3_basic/" rel="alternate" type="text/html" title="Boto3를 이용한 Amazon S3, Kinesis Data Firehose 사용하기" /><published>2019-12-16T00:00:00+09:00</published><updated>2019-12-16T00:00:00+09:00</updated><id>http://localhost:4000/boto3/boto3_basic</id><content type="html" xml:base="http://localhost:4000/boto3/boto3_basic/">&lt;h1 id=&quot;테스트-목적&quot;&gt;테스트 목적&lt;/h1&gt;

&lt;p&gt;AWS를 Python 개발환경에서 사용하기 위한 방법중 하나는 Boto3 라이브러리를 이용하는 것이다.&lt;/p&gt;

&lt;p&gt;이 테스트는 Boto3를 이용하여 아래의 서비스에 접근하여 사용하는 방법을 공유하기 위한 목적이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon S3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kinesis Firehose&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;테스트-환경&quot;&gt;테스트 환경&lt;/h1&gt;

&lt;p&gt;테스트 환경은 다음과 같다.&lt;/p&gt;

&lt;p&gt;OS : macOS mojave 10.14.6&lt;/p&gt;

&lt;p&gt;Python 버전 : 3.7.3&lt;/p&gt;

&lt;p&gt;Boto3 버전 : 1.9.215&lt;/p&gt;

&lt;p&gt;AWS CLI 버전 정보&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;aws-cli : 1.16.222 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python : 2.7.16 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Darwin : 18.7.0 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;botocore : 1.12.212&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tree 버전 : 1.8.0&lt;/p&gt;

&lt;p&gt;테스트 사전 정보&lt;/p&gt;

&lt;p&gt;다음과 같은 사전 정보가 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;테스트 환경 구성 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;awscli 설치 및 사용법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테스트-환경-구성-방법&quot;&gt;테스트 환경 구성 방법&lt;/h2&gt;

&lt;p&gt;virtual env로 환경을 구성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ virtualenv .venv
Using base prefix '/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7'
New python executable in /Users/kevin/dev/boto3_test/amazon_s3/.venv/bin/python3.7
Also creating executable in /Users/kevin/dev/boto3_test/amazon_s3/.venv/bin/python
Installing setuptools, pip, wheel... 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;virtual env 활성화후 boto3 설치&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source .venv/bin/activate
$ pip3 install boto3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;aws-cli-사용법&quot;&gt;AWS CLI 사용법&lt;/h2&gt;

&lt;p&gt;다음 링크를 참고한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-macos.html&quot;&gt;macOS에 AWS CLI 설치&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-services-s3.html&quot;&gt;AWS CLI에서 Amazon S3 사용&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;테스트--amazon-s3&quot;&gt;테스트 : Amazon S3&lt;/h1&gt;

&lt;h2 id=&quot;테스트-목적-1&quot;&gt;테스트 목적&lt;/h2&gt;

&lt;p&gt;S3 사용에 있어 다음과 같은 케이스가 발생할 것으로 예상된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 파일을 S3에 업로드 하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3에서 로컬로 파일 다운로드하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3에서 파일 삭제하기 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3의 디렉터리를 로컬로 다운로드하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 디렉터리를 S3에 업로드 하기&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 테스트는 위의 케이스 별로 시나리오대로 진행하고 나온 결과가 올바른 지를 확인하는 데에 목적이 있다.&lt;/p&gt;

&lt;h2 id=&quot;케이스별-공통사항&quot;&gt;케이스별 공통사항&lt;/h2&gt;

&lt;p&gt;세부 케이스를 진행하는데 이 테스트에서는 다음과 같은 공통사항이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;미리 지정한 profile로 session 인스턴스 생성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;session 인스턴스로 s3 resource 인스턴스 생성&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python 코드로 정리하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3

def get_s3():
    # aws profile
    session = boto3.Session(profile_name=&quot;test&quot;)
    s3 = session.resource('s3')
    return s3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;케이스--로컬-파일을-s3에-업로드-하기&quot;&gt;케이스 : 로컬 파일을 S3에 업로드 하기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 진행한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 파일을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성된 로컬 파일을 s3://bucket/boto3-test/ 경로에 업로드 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음과 같이 Python 코드를 작성하고 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3

def get_s3():
    session = boto3.Session(profile_name=&quot;test&quot;)
    s3 = session.resource('s3')
    return s3


def make_file(path=&quot;./boto3_file_upload_test.txt&quot;):
    with open(path, &quot;w&quot;) as wf:
        wf.write(&quot;This file boto3 file upload test !!!!&quot;)


def main():
    # make file
    file_path = &quot;./boto3_file_upload_test.txt&quot;
    make_file(file_path)

    # upload s3
    s3 = get_s3()
    bucket = s3.Bucket('bucket')
    bucket.upload_file(
        file_path, 'boto3-test/boto3_file_upload_test.txt')


if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성한 로컬 파일이 s3에 업로드 되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://bucket/boto3-test/
2019-08-23 14:39:54          0
2019-08-23 14:45:08         37 boto3_file_upload_test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;파일을 생성하여 Boto3를 이용하여 S3에 업로드한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS CLI를 통해 생성된 파일이 업로드가 된 것을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;케이스--s3에서-로컬로-파일-다운로드하기&quot;&gt;케이스 : S3에서 로컬로 파일 다운로드하기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 진행한다.&lt;/p&gt;

&lt;p&gt;s3://bucket/boto3-test/boto3_file_upload.txt 파일을 로컬로 다운로드 한다.&lt;/p&gt;

&lt;p&gt;다음과 같이 Python코드를 작성하고 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3

def get_s3():
    # aws profile
    session = boto3.Session(profile_name=&quot;test&quot;)
    s3 = session.resource('s3')
    return s3

def main():
    download_file_path = &quot;./boto3_file_upload_test2.txt&quot;

    # download s3
    s3 = get_s3()
    bucket = s3.Bucket('bucket')
    bucket.download_file(
        'boto3-test/boto3_file_upload_test.txt', download_file_path)

if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다운로드한 파일을 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat boto3_file_upload_test2.txt
This file boto3 file upload test !!!!%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 S3의 업로드된 파일을 다운로드한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;커널 명령을 통해 실제로 S3에서 파일이 다운로드 된 것을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;케이스--s3의-파일-삭제하기&quot;&gt;케이스 : S3의 파일 삭제하기 &lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 진행한다.&lt;/p&gt;

&lt;p&gt;s3://bucket/boto3-test/boto3_file_upload.txt 파일을 삭제한다.&lt;/p&gt;

&lt;p&gt;다음과 같이 Python코드를 작성하고 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3

def get_s3():
    # aws profile
    session = boto3.Session(profile_name=&quot;test&quot;)
    s3 = session.resource('s3')
    return s3

def main():
    # delete s3
    s3 = get_s3()
    bucket = s3.Bucket('bucket')
    obj = bucket.Object('boto3-test/boto3_file_upload_test.txt')
    obj.delete()

if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;삭제 되었는지 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://bucket/boto3-test/
2019-08-23 14:39:54          0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 S3의 업로드된 파일을 삭제한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS CLI를 통해 실제로 S3에서 파일이 삭제 된 것을 확인할 수 있었다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;케이스--s3-디렉터리-다운로드-하기&quot;&gt;케이스 : S3 디렉터리 다운로드 하기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 진행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;위의 S3 경로 s3://bucket/boto3-test/download_test_directory 디렉터리(빈 디렉터리는 제외)를 로컬로 다운로드한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다운로드 할 파일을 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://bucket/boto3-test/download_test_directory --recursive
2019-08-26 19:07:16         39 boto3-test/download_test_directory/dir1/dir1_1/dir1_1_file1.txt
2019-08-26 19:07:17         39 boto3-test/download_test_directory/dir1/dir1_1/dir1_1_file2.txt
2019-08-26 19:07:15         39 boto3-test/download_test_directory/dir1/dir1_file1.txt
2019-08-26 19:07:14         39 boto3-test/download_test_directory/dir2/dir2_file1.txt
2019-08-26 19:07:14         39 boto3-test/download_test_directory/dir2/dir2_file2.txt
2019-08-26 19:08:10          0 boto3-test/download_test_directory/dir3/
2019-08-26 19:07:13         39 boto3-test/download_test_directory/file1.txt
2019-08-26 19:07:13         39 boto3-test/download_test_directory/file2.txt 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 Python 코드를 작성하고 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3
import os


def get_s3():
    session = boto3.Session(profile_name=&quot;test&quot;)
    s3 = session.resource('s3')
    return s3


def download_directory_to_s3(s3_dir_path, local_dir_path):
    s3 = get_s3()
    bucket = s3.Bucket('bucket')

    path_list = list()
    for obj in bucket.objects.filter(Prefix=s3_dir_path):
        s3_path = obj.key
        local_path = s3_path.replace(s3_dir_path, local_dir_path)

        if s3_path[-1] == '/':
            continue

        dir_name = os.path.dirname(local_path)
        if not os.path.exists(dir_name):
            print(&quot;make directory {}&quot;.format(dir_name))
            os.makedirs(dir_name)

        path_list.append([s3_path, local_path])

    for path in path_list:
        print(&quot;Download from {} to {}&quot;.format(path[0], path[1]))
        bucket.download_file(path[0], path[1])


def main():
    parameter = {&quot;s3_dir_path&quot;: &quot;boto3-test/download_test_directory/&quot;,
                 &quot;local_dir_path&quot;: &quot;./download_test_directory/&quot;,
                 }
    download_directory_to_s3(**parameter)


if __name__ == &quot;__main__&quot;:
    main()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디렉터리가 정상적으로 다운로드 되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tree download_test_directory
download_test_directory
├── dir1
│   ├── dir1_1
│   │   ├── dir1_1_file1.txt
│   │   └── dir1_1_file2.txt
│   └── dir1_file1.txt
├── dir2
│   ├── dir2_file1.txt
│   └── dir2_file2.txt
├── file1.txt
└── file2.txt
3 directories, 7 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 S3의 업로드된 디렉터리를 로컬로 다운로드한다. (빈 디렉터리는 제외)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;커널 명령을 통해 실제로 S3에서 로컬로 디렉터리가 다운로드 된 것을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;케이스--로컬-디렉터리를-s3에-업로드-하기&quot;&gt;케이스 : 로컬 디렉터리를 S3에 업로드 하기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 테스트를 진행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;로컬 디렉터리(빈 디렉터리는 제외)를 s3 경로 s3://bucket/boto3-test/upload_test_directory에 업로드 한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;업로드할 디렉터리는 다음과 같은 구조로 이루어져 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tree upload_test_directory
upload_test_directory
├── dir1
│   ├── dir1_1
│   │   ├── dir1_1_file1.txt
│   │   └── dir1_1_file2.txt
│   └── dir1_file1.txt
├── dir2
│   ├── dir2_file1.txt
│   └── dir2_file2.txt
├── dir3
├── file1.txt
└── file2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 Python 코드를 작성하고 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3
import os


def get_s3():
    session = boto3.Session(profile_name=&quot;test&quot;)
    s3 = session.resource('s3')
    return s3


def upload_directory_to_s3(local_dir_path, s3_dir_path):
    path_list = list()
    for path, sub_dirs, files in os.walk(local_dir_path):
        for filename in files:
            local_file_path = os.path.join(path, filename)

            s3_file_path_depart = [s3_dir_path,
                                   os.path.relpath(local_file_path, local_dir_path)]
            s3_file_path = &quot;&quot;.join(s3_file_path_depart)
            path_list.append([local_file_path, s3_file_path])

    s3 = get_s3()
    bucket = s3.Bucket('bucket')

    for paths in path_list:
        print(&quot;upload from {} to {}&quot;.format(paths[0], paths[1]))
        bucket.upload_file(paths[0], paths[1])


def main():
    parameter = {&quot;local_dir_path&quot;: &quot;./upload_test_directory/&quot;,
                 &quot;s3_dir_path&quot;: &quot;boto3-test/upload_test_directory/&quot;}
    upload_directory_to_s3(**parameter)


if __name__ == &quot;__main__&quot;:
    main()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;os 모듈중 정리가 필요한 메서드를 아래에 정리하였다.&lt;/p&gt;

&lt;p&gt;os.walk(디렉터리 경로)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;해당 디렉터리 경로를 중심으로 하위 디렉터리를 탐색하여 generator 타입로 반환해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반환되는 정보는 path, sub_dirs, files 형태이며 이에 대한 설명은 다음과 같다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;path : 경로&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;sub_dirs : path 하위 디렉터리들의 이름들&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;files : path 하위 파일의 이름들&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;디렉터리의 업로드가 잘 되었는지 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://bucket/boto3-test/upload_test_directory/ --recursive
2019-08-26 16:42:02       6148 boto3-test/upload_test_directory/.DS_Store
2019-08-26 16:42:04       6148 boto3-test/upload_test_directory/dir1/.DS_Store
2019-08-26 16:42:05       6148 boto3-test/upload_test_directory/dir1/dir1_1/.DS_Store
2019-08-26 16:42:07         37 boto3-test/upload_test_directory/dir1/dir1_1/dir1_1_file1.txt
2019-08-26 16:42:08         37 boto3-test/upload_test_directory/dir1/dir1_1/dir1_1_file2.txt
2019-08-26 16:42:04         37 boto3-test/upload_test_directory/dir1/dir1_file1.txt
2019-08-26 16:42:03         37 boto3-test/upload_test_directory/dir2/dir2_file1.txt
2019-08-26 16:42:03         37 boto3-test/upload_test_directory/dir2/dir2_file2.txt
2019-08-26 16:42:02         37 boto3-test/upload_test_directory/file1.txt
2019-08-26 16:42:01         37 boto3-test/upload_test_directory/file2.txt 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 로컬 디렉터리(빈 디렉터리는 제외)를 S3에 업로드한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS CLI 명령을 통해 실제로 로컬에서 S3에 업로드 된 것을 확인할 수 있었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;테스트--kinesis-data-firehose&quot;&gt;테스트 : Kinesis Data Firehose&lt;/h1&gt;

&lt;h2 id=&quot;테스트-목적-2&quot;&gt;테스트 목적 &lt;/h2&gt;

&lt;p&gt;Kinesis Data Firehose 사용에 있어 다음과 같은 케이스가 발생할 것으로 예상된다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Delivery stream 리스트 확인하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단일 레코드를 Firehose에 보내기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복수 레코드를 Firehose에 보내기&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 테스트는 위의 케이스 별로 시나리오대로 진행하고 나온 결과가 올바른 지를 확인하는 데에 목적이 있다.&lt;/p&gt;

&lt;h2 id=&quot;테스트전-확인사항&quot;&gt;테스트전 확인사항&lt;/h2&gt;

&lt;p&gt;테스트전 Firehose 정상 동작 확인&lt;/p&gt;

&lt;p&gt;Firehose가 정상적으로 동작하는지에 대한 확인은 Management console상에서 해당 Delivery Stream의 “Test with demo data”를 통하여 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;케이스--delivery-stream-리스트-확인하기&quot;&gt;케이스 : Delivery stream 리스트 확인하기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 진행한다.&lt;/p&gt;

&lt;p&gt;Firehose 클라이언트에 접근하여 접근가능한 Delivery stream의 목록을 출력한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 파이썬 코드를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3

def get_firehose_client():
    session = boto3.Session(profile_name=&quot;test&quot;)
    firehose = session.client(&quot;firehose&quot;)
    return firehose


def list_delivery_streams():
    firehose = get_firehose_client()

    response_direct_put = firehose.list_delivery_streams(
        DeliveryStreamType=&quot;DirectPut&quot;)
    response_kinesis_stream = firehose.list_delivery_streams(
        DeliveryStreamType=&quot;KinesisStreamAsSource&quot;)
    print(&quot;List of Deliver Streams&quot;)
    print(&quot;Direct Put : {}&quot;.format(response_direct_put[&quot;DeliveryStreamNames&quot;]))
    print(&quot;Kinesis Stream As Source : {}&quot;.format(
        response_kinesis_stream[&quot;DeliveryStreamNames&quot;]))


def main():
    list_delivery_streams()


if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬 코드를 실행하면 다음과 같은 결과를 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python3 main.py
List of Deliver Streams
DirectPut : ['test-firehose-es-poc']
KinesisStream As Source : ['test-stream-firehose-es-poc']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AWS CLI로 Delivery stream 리스트를 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws firehose list-delivery-streams
{
 &quot;DeliveryStreamNames&quot;: [
 &quot;test-firehose-es-poc&quot;,
 &quot;test-stream-firehose-es-poc&quot;
 ],
 &quot;HasMoreDeliveryStreams&quot;: false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 Delivery Stream의 목록을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS CLI 명령을 통해 실제로 확인한 결과와 Boto3로 확인한 결과가 동일함을 알 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;케이스--단일-레코드를-firehose에-보내기&quot;&gt;케이스 : 단일 레코드를 Firehose에 보내기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 진행한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 샘플 데이터를 ”test-firehose-es-poc” Delivery stream으로 전송한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
	&quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;,
	&quot;app_version&quot;: &quot;v1.5.16(90)&quot;,
	&quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
	&quot;device_manufacturer&quot;: &quot;LG&quot;,
	&quot;device_name&quot;: &quot;LG G7 ThinQ&quot;,
	&quot;device_model&quot;: &quot;LM-G710N&quot;,
	&quot;device_os&quot;: &quot;Android&quot;,
	&quot;device_os_number&quot;: &quot;8.0&quot;,
	&quot;event&quot;: &quot;interest_service_click&quot;,
	&quot;interest_id&quot;: 1201,
	&quot;index&quot;: 1,
	&quot;interest_name&quot;: &quot;창업/스타트업&quot;,
	&quot;interest_service_id&quot;: None,
	&quot;interest_service_type&quot;: &quot;2&quot;,
	&quot;interest_service_name&quot;: &quot;piano&quot;,
	&quot;timestamp&quot;: &quot;2019-04-30T07:30:00Z&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“test-firehose-es-poc” Deliver stream은 Direct put으로 들어온 데이터를 Amazon elasticsearch에 전송하고 s3에 백업 데이터를 생성한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 Python 코드를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3
import json


def get_firehose_client():
    session = boto3.Session(profile_name=&quot;test&quot;)
    firehose = session.client(&quot;firehose&quot;)
    return firehose


def put_record_to_delivery_stream(test_data):
    print(&quot;Put record to Delivery Stream&quot;)

    firehose = get_firehose_client()

    response = firehose.put_record(
        DeliveryStreamName=&quot;test-firehose-es-poc&quot;,
        Record={&quot;Data&quot;: json.dumps(test_data, ensure_ascii=False)}
    )

    print(response)


def main():
    test_data = {
        &quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;,
        &quot;app_version&quot;: &quot;v1.5.16(90)&quot;,
        &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
        &quot;device_manufacturer&quot;: &quot;LG&quot;,
        &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;,
        &quot;device_model&quot;: &quot;LM-G710N&quot;,
        &quot;device_os&quot;: &quot;Android&quot;,
        &quot;device_os_number&quot;: &quot;8.0&quot;,
        &quot;event&quot;: &quot;interest_service_click&quot;,
        &quot;interest_id&quot;: 1201,
        &quot;index&quot;: 1,
        &quot;interest_name&quot;: &quot;창업/스타트업&quot;,
        &quot;interest_service_id&quot;: None,
        &quot;interest_service_type&quot;: &quot;2&quot;,
        &quot;interest_service_name&quot;: &quot;piano&quot;,
        &quot;timestamp&quot;: &quot;2019-04-30T07:30:00Z&quot;
    }

    put_record_to_delivery_stream(test_data)


if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python 코드를 실행하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python3 main.py
Put record to Delivery Stream
{'RecordId': 'OkvHgs4vIsuRjYw0O5VZB1EobIDBMq7nrvxe/eXDMtdQEDC+eFnEL3T5cILNN+pGD4cu284LsuuC0dAWO7GCZcU3tVcxnr8gFfYfFMsNLuz6KLrbOAV1NaN6oPcxhicH5CpdBHAsxFoZPugkAGe7axq9odkI+CMIsD76w7pHUF2I7rQUb8hswnKp1iHx6O6Ip4MbvwefA2U1kPyyqnP1hTPprg/M8xY4', 'Encrypted': False, 'ResponseMetadata': {'RequestId': 'f609df57-39b8-ccff-a3d4-eadd7b964c48', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'f609df57-39b8-ccff-a3d4-eadd7b964c48', 'x-amz-id-2': 'Rwyt+v8XyhuqHJYMgpacWRLeSUAQg7Im9hEVdeR/4Utu49+fOyxC20NmHppA9UUg2v+FiDfvVquVx1K7mrGFUiVXOXmLalUd', 'content-type': 'application/x-amz-json-1.1', 'content-length': '257', 'date': 'Mon, 26 Aug 2019 01:18:02 GMT'}, 'RetryAttempts': 0}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실제로 Amazon elasticsearch에 샘플데이터가 입력 되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XGET https://{es_address}/interest_service_click2/_search\?filter_path\=hits\&amp;amp;format\=json\&amp;amp;pretty
{
  &quot;hits&quot; : {
    &quot;total&quot; : 1,
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;interest_service_click2&quot;,
        &quot;_type&quot; : &quot;isc&quot;,
        &quot;_id&quot; : &quot;49595937143545169094912243846452981551249391789660962818.0&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;,
          &quot;app_version&quot; : &quot;v1.5.16(90)&quot;,
          &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
          &quot;device_manufacturer&quot; : &quot;LG&quot;,
          &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;,
          &quot;device_model&quot; : &quot;LM-G710N&quot;,
          &quot;device_os&quot; : &quot;Android&quot;,
          &quot;device_os_number&quot; : &quot;8.0&quot;,
          &quot;event&quot; : &quot;interest_service_click&quot;,
          &quot;interest_id&quot; : 1201,
          &quot;index&quot; : 1,
          &quot;interest_name&quot; : &quot;창업/스타트업&quot;,
          &quot;interest_service_id&quot; : null,
          &quot;interest_service_type&quot; : &quot;2&quot;,
          &quot;interest_service_name&quot; : &quot;piano&quot;,
          &quot;timestamp&quot; : &quot;2019-04-30T07:30:00Z&quot;
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Amazon elasticsearch의 백업용도로 저장된 S3를 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://test-es-raw-poc/2019/08/26/01/
2019-08-26 10:19:05        520 test-firehose-es-poc-1-2019-08-26-01-18-03-d2346539-c5c2-4385-b163-4b60b14ea33c

$ aws s3 cp s3://test-es-raw-poc/2019/08/26/01/test-firehose-es-poc-1-2019-08-26-01-18-03-d2346539-c5c2-4385-b163-4b60b14ea33c ./single_record.txt
download: s3://test-es-raw-poc/2019/08/26/01/test-firehose-es-poc-1-2019-08-26-01-18-03-d2346539-c5c2-4385-b163-4b60b14ea33c to ./single_record.txt

$ cat single_record.txt
{&quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot;: &quot;v1.5.16(90)&quot;, &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;, &quot;event&quot;: &quot;interest_service_click&quot;, &quot;interest_id&quot;: 1201, &quot;index&quot;: 1, &quot;interest_name&quot;: &quot;창업/스타트업&quot;, &quot;interest_service_id&quot;: null, &quot;interest_service_type&quot;: &quot;2&quot;, &quot;interest_service_name&quot;: &quot;piano&quot;, &quot;timestamp&quot;: &quot;2019-04-30T07:30:00Z&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 단일 레코드를 firehose에 전송한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon elasticsearch의 index와 S3의 백업 데이터를 확인한 결과 단일 레코드가 정상적으로 전송된 것을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;케이스--다중-레코드를-firehose에-보내기&quot;&gt;케이스 : 다중 레코드를 firehose에 보내기&lt;/h2&gt;

&lt;p&gt;다음과 같은 시나리오를 바탕으로 진행한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 샘플 데이터를 “test-firehose-es-poc” Delivery stream으로 전송한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot; : &quot;v1.5.16(90)&quot;, &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot; : &quot;LG&quot;, &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;, &quot;device_model&quot; : &quot;LM-G710N&quot;, &quot;device_os&quot; : &quot;Android&quot;, &quot;device_os_number&quot; : &quot;8.0&quot;, &quot;event&quot; : &quot;interest_service_click&quot;, &quot;interest_id&quot; : 1201, &quot;index&quot; : 1, &quot;interest_name&quot; : &quot;창업/스타트업&quot;, &quot;interest_service_id&quot; : null, &quot;interest_service_type&quot; : &quot;2&quot;, &quot;interest_service_name&quot; : &quot;piano&quot;, &quot;timestamp&quot; : &quot;2019-05-03T01:15:00Z&quot; }
{ &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot; : &quot;v1.5.16(90)&quot;, &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot; : &quot;LG&quot;, &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;, &quot;device_model&quot; : &quot;LM-G710N&quot;, &quot;device_os&quot; : &quot;Android&quot;, &quot;device_os_number&quot; : &quot;8.0&quot;, &quot;event&quot; : &quot;interest_service_click&quot;, &quot;interest_id&quot; : 1301, &quot;index&quot; : 1, &quot;interest_name&quot; : &quot;취업&quot;, &quot;interest_service_id&quot; : null, &quot;interest_service_type&quot; : &quot;배워봐요&quot;, &quot;interest_service_name&quot; : &quot;학원&quot;,  &quot;timestamp&quot; : &quot;2019-05-03T00:50:00Z&quot; }
{ &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot; : &quot;v1.5.16(90)&quot;, &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot; : &quot;LG&quot;, &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;, &quot;device_model&quot; : &quot;LM-G710N&quot;, &quot;device_os&quot; : &quot;Android&quot;, &quot;device_os_number&quot; : &quot;8.0&quot;, &quot;event&quot; : &quot;interest_service_click&quot;, &quot;interest_id&quot; : 1101, &quot;index&quot; : 1, &quot;interest_name&quot; : &quot;초등학교&quot;, &quot;interest_service_id&quot; : null, &quot;interest_service_type&quot; : &quot;물어봐요&quot;, &quot;interest_service_name&quot; : &quot;대나무숲&quot;, &quot;timestamp&quot; : &quot;2019-05-03T00:20:00Z&quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“test-firehose-es-poc” Deliver stream은 Direct put으로 들어온 데이터를 Amazon elasticsearch에 전송하고 s3에 백업 데이터를 생성한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 Python 코드를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import boto3
import json


def get_firehose_client():
    session = boto3.Session(profile_name=&quot;test&quot;)
    firehose = session.client(&quot;firehose&quot;)
    return firehose

def batch_record_to_delivery_stream(test_data_list):
    print(&quot;Put multiple records to Deliver Stream&quot;)

    records = list(map(lambda data : {&quot;Data&quot;: json.dumps(data, ensure_ascii=False)}, test_data_list))

    firehose = get_firehose_client()
    
    response = firehose.put_record_batch(DeliveryStreamName=&quot;test-firehose-es-poc&quot;,Records=records)
    print(response)

def main():
    test_data_list = [
            {
                &quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;,
                &quot;app_version&quot;: &quot;v1.5.16(90)&quot;,
                &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
                &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;,
                &quot;event&quot;: &quot;interest_service_click&quot;,
                &quot;interest_id&quot;: 1101,
                &quot;index&quot;: 1,
                &quot;interest_name&quot;: &quot;초등학교&quot;, &quot;interest_service_id&quot;: None, &quot;interest_service_type&quot;: &quot;물어봐요&quot;,&quot;interest_service_name&quot;: &quot;대나무숲&quot;,
                &quot;timestamp&quot;: &quot;2019-05-03T00:20:00Z&quot;
            },
            {
                &quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;,
                &quot;app_version&quot;: &quot;v1.5.16(90)&quot;,
                &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
                &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;,
                &quot;event&quot;: &quot;interest_service_click&quot;,
                &quot;interest_id&quot;: 1301,
                &quot;index&quot;: 1,
                &quot;interest_name&quot;: &quot;취업&quot;, &quot;interest_service_id&quot;: None, &quot;interest_service_type&quot;: &quot;배워봐요&quot;,&quot;interest_service_name&quot;: &quot;학원&quot;,
                &quot;timestamp&quot;: &quot;2019-05-03T00:50:00Z&quot;
            },
            {
                &quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;,
                &quot;app_version&quot;: &quot;v1.5.16(90)&quot;,
                &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
                &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;,
                &quot;event&quot;: &quot;interest_service_click&quot;,
                &quot;interest_id&quot;: 1201,
                &quot;index&quot;: 1,
                &quot;interest_name&quot;: &quot;창업/스타트업&quot;, &quot;interest_service_id&quot;: None, &quot;interest_service_type&quot;: &quot;2&quot;,&quot;interest_service_name&quot;: &quot;piano&quot;,
                &quot;timestamp&quot;: &quot;2019-05-03T01:15:00Z&quot;
            },
            {
                &quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;,
                &quot;app_version&quot;: &quot;v1.5.16(90)&quot;,
                &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
                &quot;device_manufacturer&quot;: &quot;LG&quot;,
                &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;,
                &quot;device_model&quot;: &quot;LM-G710N&quot;,
                &quot;device_os&quot;: &quot;Android&quot;,
                &quot;device_os_number&quot;: &quot;8.0&quot;,
                &quot;event&quot;: &quot;interest_service_click&quot;,
                &quot;interest_id&quot;: 1201,
                &quot;index&quot;: 1,
                &quot;interest_name&quot;: &quot;창업/스타트업&quot;,
                &quot;interest_service_id&quot;: None,
                &quot;interest_service_type&quot;: &quot;2&quot;,
                &quot;interest_service_name&quot;: &quot;piano&quot;,
                &quot;timestamp&quot;: &quot;2019-04-30T07:30:00Z&quot;
            }
        ]
    
	batch_record_to_delivery_stream(test_data_list)

if __name__ == &quot;__main__&quot;:
    main()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드를 실행하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python3 main.py
Put multiple records to Deliver Stream
{'FailedPutCount': 0, 'Encrypted': False, 'RequestResponses': [{'RecordId': 'JvtN3+H/2oeKA6g087JPipW+g8STzCQQp50mcIw5FQ0wQIC2EihXrB1C31kMjNXY0lcQvXo6bn3H1O/PQMWI3veWxxCb9vkL3lieblJOu+v/q8TLAlsfNCsMADGz9yPLQg4B5uRfogNKv1+M44c6RnAHIg+n5aX/K8UUgbVVF47ZeyiJsokbshNmhO7F8+3BA4rAdXW2O4hSZj640O0RAtw6QuTB3CQN'}, {'RecordId': 'JT+5YNtI/3nwtCiiaoA/w5pBxkHYdbJFwGv8KiYDk7cTjIhenCGmnlBZqpwDswVWNGdnTT+e/qEP3VQI2dx1cwjHDpRRlilNBOYwKZaueoazeQ77p2NKgarweztvVVK1r91PjIlEUlW3fJfSAqiZsCoa6NQDs3u51gRNxi8Z9iBA/3uUXDehUkszxmlIzpvFKmrYrJ6UGIdBDHIpyqmWYdCAwAXJJTBk'}, {'RecordId': 'Mriv4BFuAEpziVO0hX0zZsoCspb8Sl4fdTOUitqYYTKGhfr+7noUWfYTTp0QF0JkuS8z/KHEr8aiV53IrLe860NzZY1mSN4ZAxmIKLxQqwQceFaj0xEBJJuYjrSOuDKRVD3rCz8n/Ab4QzEP/FOrUioKK7uf4kySsE7TvTkW1pWeKHabE27FjK/+9x4//3ep3fjp5K3TO81UX6Xk7AFa5BxiGUjVzcTI'}], 'ResponseMetadata': {'RequestId': 'c59f84d4-d42a-432f-9042-d44926133eb6', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'c59f84d4-d42a-432f-9042-d44926133eb6', 'x-amz-id-2': '01OYNLqVZ9T7VGgpQ/pSJ1MtwblA5/kShluUDM6sLzv4ncJEyTrM7lHoKxEwo1EWzbXZmIu7Nz0oaw72UhQhAzAl3Ji9BgqZ', 'content-type': 'application/x-amz-json-1.1', 'content-length': '779', 'date': 'Mon, 26 Aug 2019 03:13:32 GMT'}, 'RetryAttempts': 0}}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실제 Amazon elasticsearch에서 레코드가 입력되었는지 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -XGET https://{es_address}/interest_service_click2/_search\?filter_path\=hits\&amp;amp;format\=json\&amp;amp;pretty
{
  &quot;hits&quot; : {
    &quot;total&quot; : 4,
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;interest_service_click2&quot;,
        &quot;_type&quot; : &quot;isc&quot;,
        &quot;_id&quot; : &quot;49595937143545169094912246787272632161781037484956712962.0&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;,
          &quot;app_version&quot; : &quot;v1.5.16(90)&quot;,
          &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
          &quot;device_manufacturer&quot; : &quot;LG&quot;,
          &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;,
          &quot;device_model&quot; : &quot;LM-G710N&quot;,
          &quot;device_os&quot; : &quot;Android&quot;,
          &quot;device_os_number&quot; : &quot;8.0&quot;,
          &quot;event&quot; : &quot;interest_service_click&quot;,
          &quot;interest_id&quot; : 1201,
          &quot;index&quot; : 1,
          &quot;interest_name&quot; : &quot;창업/스타트업&quot;,
          &quot;interest_service_id&quot; : null,
          &quot;interest_service_type&quot; : &quot;2&quot;,
          &quot;interest_service_name&quot; : &quot;piano&quot;,
          &quot;timestamp&quot; : &quot;2019-05-03T01:15:00Z&quot;
        }
      },
      {
        &quot;_index&quot; : &quot;interest_service_click2&quot;,
        &quot;_type&quot; : &quot;isc&quot;,
        &quot;_id&quot; : &quot;49595937143545169094912246787271423235961422855782006786.0&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;,
          &quot;app_version&quot; : &quot;v1.5.16(90)&quot;,
          &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
          &quot;device_manufacturer&quot; : &quot;LG&quot;,
          &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;,
          &quot;device_model&quot; : &quot;LM-G710N&quot;,
          &quot;device_os&quot; : &quot;Android&quot;,
          &quot;device_os_number&quot; : &quot;8.0&quot;,
          &quot;event&quot; : &quot;interest_service_click&quot;,
          &quot;interest_id&quot; : 1301,
          &quot;index&quot; : 1,
          &quot;interest_name&quot; : &quot;취업&quot;,
          &quot;interest_service_id&quot; : null,
          &quot;interest_service_type&quot; : &quot;배워봐요&quot;,
          &quot;interest_service_name&quot; : &quot;학원&quot;,
          &quot;timestamp&quot; : &quot;2019-05-03T00:50:00Z&quot;
        }
      },
      {
        &quot;_index&quot; : &quot;interest_service_click2&quot;,
        &quot;_type&quot; : &quot;isc&quot;,
        &quot;_id&quot; : &quot;49595937143545169094912246787270214310141808226607300610.0&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;user_id&quot; : &quot;Aster-Kotlin-Sapphire-564&quot;,
          &quot;app_version&quot; : &quot;v1.5.16(90)&quot;,
          &quot;device_id&quot; : &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;,
          &quot;device_manufacturer&quot; : &quot;LG&quot;,
          &quot;device_name&quot; : &quot;LG G7 ThinQ&quot;,
          &quot;device_model&quot; : &quot;LM-G710N&quot;,
          &quot;device_os&quot; : &quot;Android&quot;,
          &quot;device_os_number&quot; : &quot;8.0&quot;,
          &quot;event&quot; : &quot;interest_service_click&quot;,
          &quot;interest_id&quot; : 1101,
          &quot;index&quot; : 1,
          &quot;interest_name&quot; : &quot;초등학교&quot;,
          &quot;interest_service_id&quot; : null,
          &quot;interest_service_type&quot; : &quot;물어봐요&quot;,
          &quot;interest_service_name&quot; : &quot;대나무숲&quot;,
          &quot;timestamp&quot; : &quot;2019-05-03T00:20:00Z&quot;
        }
      },
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;백업용 s3 데이터를 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ aws s3 ls s3://test-es-raw-poc/2019/08/26/03/
2019-08-26 12:14:35       1528 test-firehose-es-poc-1-2019-08-26-03-13-33-dd434742-87da-4cbe-b62a-b84c0366215f

$ aws s3 cp s3://test-es-raw-poc/2019/08/26/03/test-firehose-es-poc-1-2019-08-26-03-13-33-dd434742-87da-4cbe-b62a-b84c0366215f ~/dev/boto3_test/kinesis_data_firehose/multiple_record.txt
download: s3://test-es-raw-poc/2019/08/26/03/test-firehose-es-poc-1-2019-08-26-03-13-33-dd434742-87da-4cbe-b62a-b84c0366215f to dev/boto3_test/kinesis_data_firehose/multiple_record.txt

$ cat dev/boto3_test/kinesis_data_firehose/multiple_record.txt
{&quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot;: &quot;v1.5.16(90)&quot;, &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;, &quot;event&quot;: &quot;interest_service_click&quot;, &quot;interest_id&quot;: 1101, &quot;index&quot;: 1, &quot;interest_name&quot;: &quot;초등학교&quot;, &quot;interest_service_id&quot;: null, &quot;interest_service_type&quot;: &quot;물어봐요&quot;, &quot;interest_service_name&quot;: &quot;대나무숲&quot;, &quot;timestamp&quot;: &quot;2019-05-03T00:20:00Z&quot;}
{&quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot;: &quot;v1.5.16(90)&quot;, &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;, &quot;event&quot;: &quot;interest_service_click&quot;, &quot;interest_id&quot;: 1301, &quot;index&quot;: 1, &quot;interest_name&quot;: &quot;취업&quot;, &quot;interest_service_id&quot;: null, &quot;interest_service_type&quot;: &quot;배워봐요&quot;, &quot;interest_service_name&quot;: &quot;학원&quot;, &quot;timestamp&quot;: &quot;2019-05-03T00:50:00Z&quot;}
{&quot;user_id&quot;: &quot;Aster-Kotlin-Sapphire-564&quot;, &quot;app_version&quot;: &quot;v1.5.16(90)&quot;, &quot;device_id&quot;: &quot;a03cd3d6-0b14-46e1-a2c8-18b1c86cf738&quot;, &quot;device_manufacturer&quot;: &quot;LG&quot;, &quot;device_name&quot;: &quot;LG G7 ThinQ&quot;, &quot;device_model&quot;: &quot;LM-G710N&quot;, &quot;device_os&quot;: &quot;Android&quot;, &quot;device_os_number&quot;: &quot;8.0&quot;, &quot;event&quot;: &quot;interest_service_click&quot;, &quot;interest_id&quot;: 1201, &quot;index&quot;: 1, &quot;interest_name&quot;: &quot;창업/스타트업&quot;, &quot;interest_service_id&quot;: null, &quot;interest_service_type&quot;: &quot;2&quot;, &quot;interest_service_name&quot;: &quot;piano&quot;, &quot;timestamp&quot;: &quot;2019-05-03T01:15:00Z&quot;}%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과는 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boto3를 이용하여 다중 레코드를 firehose에 전송한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon elasticsearch의 index와 S3의 백업 데이터를 확인한 결과 다중 레코드가 정상적으로 전송된 것을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Boto3" /><category term="AWS_S3" /><category term="AWS_Kinesis_firehose" /><summary type="html">AWS를 Python 개발환경에서 사용하기 위한 방법중 하나는 Boto3 라이브러리를 이용하는 것이다. 이 테스트는 Boto3를 이용하여 아래의 서비스에 접근하여 사용하는 방법을 공유하기 위한 목적이 있다.</summary></entry><entry><title type="html">Django framework를 이용해 게시판 만들고 AWS에 배포하기</title><link href="http://localhost:4000/django/django_make_board/" rel="alternate" type="text/html" title="Django framework를 이용해 게시판 만들고 AWS에 배포하기" /><published>2019-12-13T00:00:00+09:00</published><updated>2019-12-13T00:00:00+09:00</updated><id>http://localhost:4000/django/django_make_board</id><content type="html" xml:base="http://localhost:4000/django/django_make_board/">&lt;h1 id=&quot;문서-목적&quot;&gt;문서 목적&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;이 문서는 Django, python을 모르는 개발자를 대상으로 작성했으며 추후 다른 사람이 개발 할 경우 시행착오를 줄이는데 도움을 주기 위하여 작성하였다.&lt;/p&gt;

&lt;p&gt;처음 배울 때 겪었던 시행착오와 찾아봤던 정보들, 사이트를 중심으로 기술하였다.&lt;/p&gt;

&lt;p&gt;장고를 배우기 위해 토이프로젝트를 진행했으며 프로젝트의 목적은 Django와 AWS를 이용해 상용화 서버를 만드는 것이며 기능 구현 후 Test code도 작성했다.&lt;/p&gt;

&lt;h1 id=&quot;토이-프로젝트-환경-및-구조&quot;&gt;토이 프로젝트 환경 및 구조&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-개발-환경&quot;&gt;1. 개발 환경&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MacOS Mojave 10.14.2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python 3.6.7&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nginx/1.14.0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Django 2.1.4&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;uWSGI 2.0.17.1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MySQL 5.6.41&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;EC2 ubuntu 18.04 LTS&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RDS- MySQL 5.6.41&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-서버-구조&quot;&gt;2. 서버 구조&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;서버&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;the web client &amp;lt;-&amp;gt; the web server &amp;lt;-&amp;gt; the socket &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django&lt;/p&gt;

&lt;p&gt;브라우저 요청 -&amp;gt; 정적인 페이지/파일은 nginx에서 응답 / 동적데이터는 nginx -&amp;gt; uWSGI를 통해 django에서 처리&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/make_board_image.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;진행-내용&quot;&gt;진행 내용&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;게시판-기능-정의-및-db-모델&quot;&gt;게시판 기능 정의 및 DB 모델&lt;/h3&gt;

&lt;p&gt;토이프로젝트는 게시판 기능을 만드는 것을 목표로 하였으며 다음과 같은 기능을 구현하였다.&lt;/p&gt;

&lt;p&gt;회원가입 관련 기능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt; 첫 화면에서 로그인이 되어 있지 않으면 로그인 화면 페이지&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt; 회원 가입&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt; 로그인, 로그아웃 &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;게시글 관련 기능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt; 글 쓰기 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt; 글 삭제 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt; 글 편집 기능&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;댓글 관련 기능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt; 댓글 작성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt; 댓글 삭제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DB Model&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Post ( title, text, author, published_date)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Comment (author, text, published_date)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로컬-환경에서-게시판-만들기&quot;&gt;로컬 환경에서 게시판 만들기&lt;/h3&gt;

&lt;p&gt;자세한 사항은 장고걸스 사이트(&lt;a href=&quot;https://tutorial.djangogirls.org/ko/&quot;&gt;https://tutorial.djangogirls.org/ko/&lt;/a&gt;) 참고해 게시판을 만들면 된다.  친절하게 세세하게 설명해주고 있어 처음 보기에 좋다고 생각된다.&lt;/p&gt;

&lt;p&gt;장고걸스에서 쓰는 버전은 구버전이라 url부분은 Django 공식 사이트의 튜토리얼을 참고하면 도움이 된다.(&lt;a href=&quot;https://docs.djangoproject.com/ko/2.1/intro/tutorial01/&quot;&gt;https://docs.djangoproject.com/ko/2.1/intro/tutorial01/&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;urls 예시&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.urls import path
    
from . import views
    
urlpatterns = [
    path('', views.index, name = 'index'),
    path('&amp;lt;int:pk&amp;gt;/', views.post_detail, name = 'post_detail'),
    path('post/new/', views.post_new, name='post_new'),
    path('post/edit/&amp;lt;int:pk&amp;gt;/', views.post_edit, name='post_edit'),
    path('post/remove/&amp;lt;int:pk&amp;gt;/', views.post_remove, name='post_remove'),
    path('&amp;lt;int:pk&amp;gt;/comments/', views.add_comment_to_post, name = 'add_comment_to_post'),
    path('comments/&amp;lt;int:pk&amp;gt;/remove/', views.comment_remove, name = 'comment_remove'),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Virturalenv 만들 때 예시&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Create : virtualenv .venv 

Activate : source .venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python Class 관련 함수&lt;/p&gt;

&lt;p&gt;초기화 함수&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; __init__ : 인스턴스를 만들 때 실행되는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문자열화 함수&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; __str__ : 인스턴스 자체를 출력 할 때의 형식을 지정해주는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;aws-프로젝트-배포하기&quot;&gt;AWS 프로젝트 배포하기&lt;/h3&gt;

&lt;p&gt;링크 (&lt;a href=&quot;https://nachwon.github.io/django-deploy-1-aws/&quot;&gt;https://nachwon.github.io/django-deploy-1-aws/&lt;/a&gt;)를 참고하되 다른 점만 서술한다.&lt;/p&gt;

&lt;p&gt;EC2에는 git을 통해 소스코드를 올렸다.&lt;/p&gt;

&lt;p&gt;링크는 pyvenv로 진행했으나 해당 프로젝트는 virtualenv를 이용해서 진행해 설정 부분이 다르다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;uwsgi 설치 후 되는지 명령어로 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uwsgi --http :8000 --home /home/ubuntu/&amp;lt;project name&amp;gt;/.env --chdir /home/ubuntu/&amp;lt;project name&amp;gt;/&amp;lt;app name&amp;gt; -w mysite.wsgi 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;location /static 부분은 파이썬 명령어 collectstatic했을 때 static파일들이 모이는 곳으로 경로 설정을 해줘야 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysite.conf ( nginx 설정파일)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    listen 80;
    server_name *.amazonaws.com;
    charset utf-8;
    client_max_body_size 128M;
    location / {
        uwsgi_pass      unix:///tmp/app.sock;
        include         uwsgi_params;
    }
    
    location /static {
        alias /home/ubuntu/&amp;lt;project name&amp;gt;/&amp;lt;app name&amp;gt;/static;
    }
    location /media {
        alias /home/ubuntu/&amp;lt;project name&amp;gt;/&amp;lt;app name&amp;gt;/media;
    }
    location / {
        uwsgi_pass  django;
        include /home/ubuntu/&amp;lt;project name&amp;gt;/uwsgi_params;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 파일을 sites-enabled 폴더넣어주고 default 파일 삭제한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;uwsgi.service&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[uwsgi]
    
chdir = /home/ubuntu/&amp;lt;project name&amp;gt;/&amp;lt;app name&amp;gt;
module = mysite.wsgi:application
home = /home/ubuntu/&amp;lt;project name&amp;gt;/.env
    
uid = ubuntu
gid = ubuntu
    
socket = /tmp/mysite.sock
chmod-socket = 666
chown-socket = ubuntu:ubuntu
    
enable-threads = true
master = true
vacuum = true
pidfile = /tmp/mysite.pid
logto = /home/ubuntu/&amp;lt;project name&amp;gt;/&amp;lt;app name&amp;gt;/@(exec://date +%%Y-%%m-%%d).log
log-reopen = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;오류중에 uwsgi_prams 파일이 없어서 나는 오류가 있다. 해당 오류인지 확인하려면 etc/nginx/ 에서 확인 후 없다면 파일 생성 후 하단의 내용을 넣어주면 된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uwsgi_param     QUERY_STRING            $query_string;
uwsgi_param     REQUEST_METHOD          $request_method;
uwsgi_param     CONTENT_TYPE            $content_type;
uwsgi_param     CONTENT_LENGTH          $content_length;
     
uwsgi_param     REQUEST_URI             $request_uri;
uwsgi_param     PATH_INFO               $document_uri;
uwsgi_param     DOCUMENT_ROOT           $document_root;
uwsgi_param     SERVER_PROTOCOL         $server_protocol;
uwsgi_param     UWSGI_SCHEME            $scheme;
     
uwsgi_param     REMOTE_ADDR             $remote_addr;
uwsgi_param     REMOTE_PORT             $remote_port;
uwsgi_param     SERVER_PORT             $server_port;
uwsgi_param     SERVER_NAME             $server_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-code&quot;&gt;Test code&lt;/h3&gt;

&lt;p&gt;코드 테스트는 시나리오를 통한 테스트(selenium)과 API 테스트(Django test tool)로 진행했다.&lt;/p&gt;

&lt;p&gt;참고했던 사이트와 만들었던 코드를 올려놓고 향후 테스트 관련 더 배우게 되면 추가하겠다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Selenium은 실제 서버에 접속을 해서 테스트를 진행하는 것이기 때문에 게시물 생성시 삭제까지 진행해야 안남는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;장고 테스트 툴은 테스트할때마다 새로 DB를 만들어서 진행해 게시물 관련 테스트를 하려면 setUp함수로 미리 로그인, 생성을 해줘야됨.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Selenium 웹드라이버는 맥, 유닉스가 다르고 AWS EC2에서 진행시 headless 옵션을 넣어야 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;selenium test&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import unittest
import time
    
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
    
    
class NewVisitorTest(unittest.TestCase):
    def setUp(self):
        self.browser = webdriver.Chrome('./chromedriver')
    def tearDown(self):
        self.browser.quit()
    
    def test_can_signup(self):
        self.browser.get('{AWS_EC2_IP}')
        time.sleep(2)
    
        # 회원가입한 아이디로 로그인을 한다
        self.browser.find_element_by_id('id_username').send_keys('testid1')
        self.browser.find_element_by_id('id_password').send_keys('tjddnekd1')
        self.browser.find_element_by_xpath(&quot;//input[@value='login']&quot;).click()
        time.sleep(2)
            
if __name__ == '__main__':
    unittest.main(warnings='ignore')
    
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Django API test&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.test import TestCase
from django.urls import resolve, reverse
from .views import index, post_new, post_remove
from django.http import HttpRequest
from .models import Post
from django.contrib.auth.models import User
from django.utils import timezone
    
# Create your tests here.
class HomePageTest(TestCase):
    def test_root_url_resolves_to_home_page_view(self):
        found = resolve('/')
        self.assertEqual(found.func, index)
            
    def test_not_login_home_redirect(self):
        response = self.client.get('')
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/accounts/login')
        
    def test_login_home_redirect(self):
        self.user = User.objects.create_user(username='testuser', password='12345')
        self.assertEqual(User.objects.count(), 1)
    
        response = self.client.post('/accounts/login/', {'username':'testuser', 'password':'12345'})
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/')
        
class PostPageTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testuser', password='12345')
        self.client.login(username= 'testuser', password = '12345')
        self.assertEqual(User.objects.count(), 1)
            
        first_Post = Post()
        first_Post.text = 'first post text'
        first_Post.author = self.user
        first_Post.published_date = timezone.now()
        first_Post.pk = 1
        first_Post.save()
    
    def test_post_detail_template(self):
        response = self.client.get('/1/')
        self.assertTemplateUsed(response, 'board/post_detail.html')
        
    def test_post_new_template(self):
        response = self.client.get('/post/new/')
        self.assertEqual(response.status_code, 200)
        
    def test_post_delete(self):
        response = self.client.get(reverse(post_remove, args=[1, ]))
        self.assertEqual(response.status_code, 302)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;참고-자료-정리&quot;&gt;참고 자료 정리&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;게시판 작성 참고 자료&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tutorial.djangogirls.org/ko/&quot;&gt;https://tutorial.djangogirls.org/ko/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.1/intro/tutorial01/&quot;&gt;https://docs.djangoproject.com/ko/2.1/intro/tutorial01/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AWS 배포 참고 자료&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://nachwon.github.io/django-deploy-1-aws/&quot;&gt;https://nachwon.github.io/django-deploy-1-aws/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TEST 참고 자료&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TDD 관점에서의 간단한 테스트 코드 작성:  &lt;a href=&quot;https://wikidocs.net/11058&quot;&gt;https://wikidocs.net/11058&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클라우드 상에서 Selenium을 이용한 Django 기능 테스트 자동화: &lt;a href=&quot;https://www.pycon.kr/2016apac/program/37&quot;&gt;https://www.pycon.kr/2016apac/program/37&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파이썬에서 편하게 테스트 케이스 작성하기: &lt;a href=&quot;https://www.pycon.kr/2017/program/132&quot;&gt;https://www.pycon.kr/2017/program/132&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;유닛테스트를 작성하는 3가지 접근 방법: &lt;a href=&quot;http://americanopeople.tistory.com/285?category=567685&quot;&gt;http://americanopeople.tistory.com/285?category=567685&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saving User Input: testing the database: &lt;a href=&quot;http://www.obeythetestinggoat.com/book/chapter_post_and_database.html&quot;&gt;http://www.obeythetestinggoat.com/book/chapter_post_and_database.html&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Python" /><category term="Django" /><category term="AWS" /><category term="AWS_EC2" /><summary type="html">이 문서는 Django, python을 모르는 개발자를 대상으로 작성했으며 추후 다른 사람이 개발 할 경우 시행착오를 줄이는데 도움을 주기 위하여 작성하였다.</summary></entry><entry><title type="html">New Relic 교육 - 오버뷰</title><link href="http://localhost:4000/monitoring/newrelic_basic/" rel="alternate" type="text/html" title="New Relic 교육 - 오버뷰" /><published>2019-12-13T00:00:00+09:00</published><updated>2019-12-13T00:00:00+09:00</updated><id>http://localhost:4000/monitoring/newrelic_basic</id><content type="html" xml:base="http://localhost:4000/monitoring/newrelic_basic/">&lt;h1 id=&quot;문서목적&quot;&gt;문서목적&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://newrelic.com/&quot;&gt;New Relic&lt;/a&gt;에서 제공하는 기능에 대한 간단한 오버뷰 교육과 관련되어 사전 학습 내용과 교육 내용 일부를 개인적으로 정리한 문서이다.&lt;br /&gt;
New Relic 전반적인 내용을 다루는 상세 문서가 아니므로 정확하고, 구체적인 내용은 &lt;a href=&quot;https://newrelic.com/&quot;&gt;New Relic 공식 사이트&lt;/a&gt;나 다른 자료를 확인하도록 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;new-relic이-말하는-new-relic오버뷰&quot;&gt;New Relic이 말하는 New Relic(오버뷰)&lt;/h1&gt;

&lt;p&gt;New Relic에서 제공하는 다양한 제품을 통해 데이터 기반 분석과 대응이 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;new-relic-활용&quot;&gt;New Relic 활용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 및 관련 인프라스트럭처의 모니터링 데이터를 같이 확인할 수 있어 문제 확인 시간을 단축할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션/서비스의 code flow 기반 추적이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대시보드를 통해 가시적인 데이터 확인과 공통 대시보드를 통해 관련 팀원들이 동일한 뷰로 문제를 바라볼 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;New Relic query language(NRQL)를 사용하여 데이터를 살펴볼 수 있으며, 직관적으로 대시보드를 구성하는 것이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CloudWatch가 제공하는 모니터링 기능 이상의 기능을 통해 좀더 상세한 서비스 분석과 기능, 비기능 관련 원인 추적이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;agent-방식&quot;&gt;Agent 방식&lt;/h2&gt;

&lt;p&gt;New Relic은 기본적으로 Agent 방식으로 모니터링을 위한 데이터를 수집한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;APM agent&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Infrastructure agent&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Application과 Application 관련 호스트(서버)의 정보와 연결성을 대략적으로 확인 가능하여, 앱이 설치된 호스트이 상태와 앱의 전반적인 상태 정보를 같이 볼 수 있다.&lt;br /&gt;
인프라 모니터링은 인프라스트럭처 에이전트 설치하여 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ssh접근, 패키지 설치 등과 같은 사용자 행위에 대한 추적도 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동일 세션에서 어떤 작업이 있었는지 시간대별로 추적 가능.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Service Map&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;설치된 Agent를 통해 front - back - storage 와 같은 서비스 레이어에 다른 의존성관계를 파악할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스별 맵을 만들어서 특정 서비스 경로에 대해 모니터링 하는 것도 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;new-relic-products&quot;&gt;New Relic Products&lt;/h1&gt;

&lt;p&gt;크게 6가지 제품으로 나누어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/products/application-monitoring&quot;&gt;New Relic - APM&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/products/browser-monitoring&quot;&gt;New Relic - Browser&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/products/infrastructure&quot;&gt;New Relic - Infrastructure&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/products/insights&quot;&gt;New Relic - Insights&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/products/mobile-monitoring&quot;&gt;New Relic - Mobile&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/products/synthetics&quot;&gt;New Relic - Synthetics&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;new-relic---apm&quot;&gt;&lt;a href=&quot;https://newrelic.com/products/application-monitoring&quot;&gt;New Relic - APM&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;SaaS 기반 APM 툴을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;관리 목적으로 논리적 그룹을 구성하여 관리할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개발 언어별(Java, .Net, Python, Ruby, Node.js 등) 모니터링 뿐만 아니라 다양한 프레임워크(framework)에 대하여 지원한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 코드 세그먼트 및 SQL문이 애플리케이션 혹은 서비스 성능에 영향을 주는지 drill-down 확인이 가능하다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;코드레벨 트랜잭션 : ex&amp;gt; xx.jsp app code processing time&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;호출 과정에 대하여 원하는 클래스, 메소드 레벨 추적이 가능하다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;thread profiler 지원&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;new-relic---browser&quot;&gt;&lt;a href=&quot;https://newrelic.com/products/browser-monitoring&quot;&gt;New Relic - Browser&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;백엔드, 페이지로드 또는 그 외에서 발생하는 고객 경험 및 성능 관련 문제를 확인하고 진단하는데 도움을 준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;브라우저 버전 및 사용자 기기 유형 등 브라우저 유형별로 프런트엔드 성능 분류를 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용자의 지리적 위치(도시)까지 파악하여 최종 사용자에 대한 경험 분석을 지원한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Session Trace를 활용하여 서비스를 위한 resource(이미지, css 등) 로딩, AJAX 요청, 사용자 상호작용에 대하여 시간축을 기준으로 시각화하여 확인할 수 있는 기능을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;요청 대기열, 앱 코드, 네트워크 대기시간, DOM 처리 및 페이지 렌더링 별로 각 페이지의 로드시간 성능을 분석할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;new-relic---infrastructure&quot;&gt;&lt;a href=&quot;https://newrelic.com/products/infrastructure&quot;&gt;New Relic - Infrastructure&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;기본적으로 인프라 전반의 호스트 및 인스턴스의 기본정보에 대한 모니터링이을 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/&quot;&gt;New Relic&lt;/a&gt;은 (AWS, Docker, Bare Metal 또는 위 모든 인프라 등) 다양한 인프라 전반에 걸쳐 호스트에 대한 모든 지표 및 이벤트에 대해 실시간으로 가시성을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;New Relic은 빠른 확장, 스마트한 배포, 사전 모니터링을 수월하게 이행할 수 있도록 지원한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주요 호스트 상태 지표 (CPU, 메모리, 디스크, 네트워크) 5 초마다 새로 고침&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;커스터 쿼리와 태그기반 경고 및 대시보드를 통한 관리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;라벨, 이미지 및 기타 메타데이터 별 Docker 컨테이너 분할&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AWS EC2와 긴밀하게 통합되어 EC2 관련되어 다양한 모니터링이 기능하다.&lt;br /&gt;
New Relic Infrastructure Essentials 및 Pro는 Amazon EC2와 Docker에 대한 기본 지원과 함께 제공된다.&lt;br /&gt;
New Relic Infrastructure Pro는 다음과 같은 인기 있는 AWS 서비스에 대하여 기본 모니터링의 확장형 서비스를 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AWS IAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon CloudFront&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon DynamoDB&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon EBS&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS Route 53&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS ElastiCache&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS Elastic Load Balancing&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS Elasticsearch&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AWS Kinesis&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon Kinesis Firehose&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon SNS&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon RDS&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon ECR&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon SQS&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon VPC&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Amazon ECS&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 통합서비스를 통해 AWS사용량을 쉽게 보고 이해할 수 있다.&lt;br /&gt;
즉, AWS지출 분석,분기별 예산 검토 또는 전망 준비, 서비스 확장에 따른 영향 평가 또는 사용량과 데이터 흐름의 급등 및 급락 파악 등이 가능하기 때문에 AWS 인프라 및 앱관리를 미세조정할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;new-relic---insights&quot;&gt;&lt;a href=&quot;https://newrelic.com/products/insights&quot;&gt;New Relic - Insights&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;New Relic의 실시간 분석 플랫폼이다.&lt;br /&gt;
New Relic query language(NRQL)를 사용하여 New Relic으로 수집된 데이터에 대하여 질의가 가능하다.&lt;br /&gt;
쿼리 결과를 그래프로 가시화 하고 대시보드에 포함시키는 것이 가능하다.&lt;br /&gt;
코호트(cohort) 분석, 퍼널(funnel) 분석이 가능하다.&lt;/p&gt;

&lt;p&gt;New Relic query language(NRQL)의 기본 기능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;조회 조건 필터링 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;결과 버킷팅(bucket) 지원&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;히스토그램&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조회 결과와 필터링을 그래프와 연동&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;new-relic---mobile&quot;&gt;&lt;a href=&quot;https://newrelic.com/products/mobile-monitoring&quot;&gt;New Relic - Mobile&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;앱에 대한 사용자 활동 분석&lt;br /&gt;
앱 크래시 리포트 : 관련 지표, 빈도, 스택트레이스&lt;br /&gt;
크래시 발생시 이메일 알림등 연동&lt;/p&gt;

&lt;h2 id=&quot;new-relic---synthetics&quot;&gt;&lt;a href=&quot;https://newrelic.com/products/synthetics&quot;&gt;New Relic - Synthetics&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;사전 모니터링, 테스팅에 대한 용도로 활용할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;기타-교육중-확인한-내용&quot;&gt;기타 교육중 확인한 내용&lt;/h2&gt;

&lt;p&gt;다음은 기타 교육 설명에서 확인한 내용이나 질문을 통해 확인한 내용들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본적으로 New Relic은 Agent 설치가 필요하다. 다양한 용도의 agent를 지원하는 것으로 보인다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NRQL(New Relic Query Language)는 SQL과 유사하게 보일 수 있으나 일반적인 SQL이 아니다. 표준 ANSI SQL과 동일한 수준의 질의 기능을 제공하는 것은 아니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모니터링 데이터는 timestamp에 대한 처리는 기본적으로 UTC 기반이며, New Relic query나 New Relic 관리 console에서 timezone을 설정할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permalink 정보를 선택하여 전달하면 문의 대응에 더 좋다. Permalink에는 조회 시간범위까지 포함되어 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;커스텀 메트릭을 New Relic쪽으로 적재(insert)하는 것이 가능하며, 적재 요청시 insert용 api key를 사용하여 적재한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CloudWatch로 전달되는 aws resource 서비스 메트릭을 New Relic쪽으로 가져와서 활용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 코드에 New Relic쪽으로 데이터를 수집하기 위한 용도의 코드를 심어서 데이터 수집, 분석이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 Browser단에 JavaScript를 추가하여 테스트 목적의 데이터를 수집하여 볼 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 응답시간 기준으로 satisfied, tolerating, frustrated 버킷으로 나누어 메트릭을 분류할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 DB query 분석과 힌트(가이드) 제공 기능을 일부 포함하고 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;time marking : 어느 시점에 중요하게 어떤 이벤트가 있었는지 표시를 하여 지표 분석이나 가시화 처리에 도움을 줄 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;New Relic Alarm은 by policy, by condition, by condition and entity 3가지 형태로 동작 방식이 나누어질 수 있으며, 각 방식에 따른 동작방식을 잘 이해하고 사용해야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;New Relic Alarm은 Amazon CloudWatch의 Alarm과 유사하게 특정조건을 만족하여 최초 알람이 발생한 이후, 동일한 조건을 만족하는 알람 상황이 지속되는 경우 동일 알람 설정으로 다시 알람 액션이 발생하지는 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;참고자료&quot;&gt;참고자료&lt;/h1&gt;

&lt;p&gt;New Relic에 대한 최신 한글자료는 검색이 잘 안된다. 사이트문서와 YouTube - New Relic 채널의 자료를 참고하는 것이 좋을 것으로 보인다.&lt;br /&gt;
공식 사이트 문서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://newrelic.com/&quot;&gt;New Relic site&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.newrelic.com/&quot;&gt;New Relic Documents&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;APM: &lt;a href=&quot;https://docs.newrelic.com/docs/apm/new-relic-apm/guides/new-relic-apm-best-practices-guide&quot;&gt;https://docs.newrelic.com/docs/apm/new-relic-apm/guides/new-relic-apm-best-practices-guide&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Browser: &lt;a href=&quot;https://docs.newrelic.com/docs/browser/new-relic-browser/guides/new-relic-browser-best-practices-guide&quot;&gt;https://docs.newrelic.com/docs/browser/new-relic-browser/guides/new-relic-browser-best-practices-guide&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mobile: &lt;a href=&quot;https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/guides/new-relic-mobile-best-practices-guide&quot;&gt;https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/guides/new-relic-mobile-best-practices-guide&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insights: &lt;a href=&quot;https://docs.newrelic.com/docs/insights/use-insights-ui/guides/new-relic-insights-best-practices-guide&quot;&gt;https://docs.newrelic.com/docs/insights/use-insights-ui/guides/new-relic-insights-best-practices-guide&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Synthetics: &lt;a href=&quot;https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/getting-started/new-relic-synthetics&quot;&gt;https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/getting-started/new-relic-synthetics&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Infrastructure: &lt;a href=&quot;https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/guides/new-relic-infrastructure-best-practices-guide&quot;&gt;https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/guides/new-relic-infrastructure-best-practices-guide&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>kelpin</name><email>seongwoo.dev@gmail.com</email></author><category term="Newrelic" /><category term="Monitoring" /><summary type="html">New Relic에서 제공하는 기능에 대한 간단한 오버뷰 교육과 관련되어 사전 학습 내용과 교육 내용 일부를 개인적으로 정리한 문서이다.</summary></entry></feed>